<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Algebra Studio Balance Lab</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    body { 
      margin: 0; padding: 20px; min-height: 100vh; 
      background: #f5f5f5; display: flex; flex-direction: column; 
      align-items: center; font-family: 'Poppins', sans-serif;
      -webkit-user-select: none; user-select: none; touch-action: none;
    }
    #canvas-container { 
      position: relative; width: 900px; height: 685px;
      background: white; border-radius: 16px;
      box-shadow: 0 2px 20px rgba(0,0,0,0.08); overflow: hidden;
    }
    canvas { display: block; touch-action: none; }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <script>
    let cups = [];
    let cubes = [];
    let selectedElement = null;
    let mirrorElement = null;
    let dragOffsetX = 0, dragOffsetY = 0;
    let mode = 'challenge';
    let signMode = 'positive'; // 'positive' or 'negative'
    let signToggleHover = false;
    let questionType = '2-step';
    let questionTypes = ['1-step', '1-step with ( - )', '2-step', '2-step with ( - )', 'Distributive'];
    let dropdownOpen = false;
    let dropdownHoverIndex = -1;
    let targetA = 2, targetB = 3, targetC = 7, targetSolution = 2;
    let distributiveA = 2, distributiveB = 3;
    let leftSide = { cups: 0, positiveCubes: 0, negativeCubes: 0 };
    let rightSide = { cups: 0, positiveCubes: 0, negativeCubes: 0 };
    let phase = 'build';
    let leftMatch = false, rightMatch = false;
    let xValue = null;
    let xInputNegative = false;
    let solveSteps = [];
    let xInputFocused = false;
    let cursorBlink = 0;
    let showWrongAnswer = false;
    let wrongAnswerTimer = 0;
    let zeroOutAnimating = false;
    let zeroOutPairs = [];
    let zeroOutProgress = 0;
    let fadingElements = [];
    let solveButtonHover = false, newQuestionHover = false;
    let challengeTabHover = false, buildTabHover = false;
    let nextButtonHover = false, zeroOutHover = false, checkHover = false;
    let clearButtonHover = false;
    let dropdownButtonHover = false;
    
    let equationBalanced = true;
    
    let balanceTilt = 0;
    let balanceTiltTarget = 0;
    let balanceTiltMax = 8;
    
    // Padding offset
    const PAD = 8;
    const TABS_Y = 25 + PAD, EQUATION_Y = 70 + PAD, STEPS_START_Y = 130 + PAD;
    const BALANCE_BEAM_Y = 385, EQUATION_DISPLAY_Y = 465;
    const BUTTON_Y = 535, SOURCE_Y = 627;
    const DROPDOWN_Y = 62 + PAD;
    
    // Horizontal bounds (with padding)
    const LEFT_EDGE = 58;
    const RIGHT_EDGE = 842;
    const CENTER_X = 450;
    const LEFT_CENTER = 230;
    const RIGHT_CENTER = 670;

    function setup() {
      let canvas = createCanvas(900, 685);
      canvas.parent('canvas-container');
      generateNewProblem();
    }

    function generateNewProblem() {
      if (mode === 'challenge') {
        generateProblemForType(questionType);
      }
      clearBalance();
    }
    
    function generateProblemForType(type) {
      if (type === '1-step') {
        if (random() < 0.5) {
          targetA = floor(random(2, 5));
          targetB = 0;
          targetSolution = floor(random(1, 6));
          targetC = targetA * targetSolution;
        } else {
          targetA = 1;
          targetB = floor(random(1, 9));
          targetSolution = floor(random(1, 6));
          targetC = targetSolution + targetB;
        }
      } else if (type === '1-step with ( - )') {
        if (random() < 0.5) {
          targetA = floor(random(2, 5));
          targetB = 0;
          targetSolution = floor(random(-5, 6));
          if (targetSolution === 0) targetSolution = 1;
          targetC = targetA * targetSolution;
        } else {
          targetA = 1;
          targetB = floor(random(-8, 9));
          if (targetB === 0) targetB = 1;
          targetSolution = floor(random(-5, 6));
          if (targetSolution === 0) targetSolution = 1;
          targetC = targetSolution + targetB;
        }
      } else if (type === '2-step') {
        targetSolution = floor(random(1, 6));
        targetA = floor(random(1, 5));
        targetB = floor(random(1, 7));
        targetC = targetA * targetSolution + targetB;
      } else if (type === '2-step with ( - )') {
        targetSolution = floor(random(-5, 6));
        if (targetSolution === 0) targetSolution = 1;
        targetA = floor(random(1, 5));
        targetB = floor(random(-6, 7));
        if (targetB === 0) targetB = 1;
        targetC = targetA * targetSolution + targetB;
      } else if (type === 'Distributive') {
        targetSolution = floor(random(1, 5));
        distributiveA = floor(random(2, 5));
        distributiveB = floor(random(1, 5));
        targetA = distributiveA;
        targetB = distributiveA * distributiveB;
        targetC = distributiveA * (targetSolution + distributiveB);
      }
    }
    
    function clearBalance() {
      cups = []; cubes = [];
      leftSide = { cups: 0, positiveCubes: 0, negativeCubes: 0 };
      rightSide = { cups: 0, positiveCubes: 0, negativeCubes: 0 };
      phase = 'build'; leftMatch = false; rightMatch = false;
      xValue = null; xInputNegative = false; solveSteps = []; xInputFocused = false;
      showWrongAnswer = false; wrongAnswerTimer = 0;
      zeroOutAnimating = false; zeroOutPairs = [];
      equationBalanced = true;
      balanceTilt = 0; balanceTiltTarget = 0;
    }

    function draw() {
      background(255);
      updateAnimations();
      drawModeTabs();
      drawEquationArea();
      drawSolveSteps();
      drawBalance();
      drawZeroOutButton();
      drawElementsOnBalance();
      drawEquationDisplay();
      drawButtons();
      drawSourceArea();
      if (selectedElement) drawDraggedElement(selectedElement);
      drawFadingElements();
      drawZeroOutAnimation();
      drawDropdown();
    }

    function drawModeTabs() {
      let tabH = 32;
      let challengeX = LEFT_EDGE - 17, challengeW = 100;
      if (mode === 'challenge') {
        fill(100, 60, 160); noStroke();
        rect(challengeX, TABS_Y, challengeW, tabH, 16); fill(255);
      } else {
        fill(challengeTabHover ? 240 : 250);
        stroke(220); strokeWeight(1);
        rect(challengeX, TABS_Y, challengeW, tabH, 16); fill(120);
      }
      noStroke(); textSize(13); textFont('Poppins');
      textAlign(CENTER, CENTER);
      text('Challenge', challengeX + challengeW/2, TABS_Y + tabH/2);
      
      // Dropdown button under Challenge (only in challenge mode)
      if (mode === 'challenge') {
        let dbX = LEFT_EDGE - 17, dbW = 130, dbH = 24;
        fill(dropdownButtonHover || dropdownOpen ? 235 : 245);
        stroke(200); strokeWeight(1);
        rect(dbX, DROPDOWN_Y, dbW, dbH, 12);
        fill(100); noStroke();
        textSize(11);
        text(questionType + ' ▼', dbX + dbW/2, DROPDOWN_Y + dbH/2);
      }
      
      let buildX = 165, buildW = 140;
      if (mode === 'build') {
        fill(100, 60, 160); noStroke();
        rect(buildX, TABS_Y, buildW, tabH, 16); fill(255);
      } else {
        fill(buildTabHover ? 240 : 250);
        stroke(220); strokeWeight(1);
        rect(buildX, TABS_Y, buildW, tabH, 16); fill(120);
      }
      noStroke(); textSize(13);
      text('Build an Equation', buildX + buildW/2, TABS_Y + tabH/2);
      
      // New Question button - symmetric with Challenge (41px from edge)
      let nqX = 744, nqW = 115;
      fill(newQuestionHover ? 240 : 250);
      stroke(220); strokeWeight(1);
      rect(nqX, TABS_Y, nqW, tabH, 16);
      fill(120); noStroke();
      text('New Question', nqX + nqW/2, TABS_Y + tabH/2);
    }
    
    function drawDropdown() {
      if (!dropdownOpen || mode !== 'challenge') return;
      
      let dbX = LEFT_EDGE - 17, dbW = 130, itemH = 28;
      let startY = DROPDOWN_Y + 28;
      
      fill(255); stroke(200); strokeWeight(1);
      rect(dbX, startY, dbW, questionTypes.length * itemH, 8);
      
      noStroke(); textSize(11); textAlign(CENTER, CENTER);
      for (let i = 0; i < questionTypes.length; i++) {
        let itemY = startY + i * itemH;
        if (i === dropdownHoverIndex) {
          fill(240);
          rect(dbX + 2, itemY + 2, dbW - 4, itemH - 2, i === 0 ? 6 : 0, i === 0 ? 6 : 0, i === questionTypes.length - 1 ? 6 : 0, i === questionTypes.length - 1 ? 6 : 0);
        }
        fill(questionTypes[i] === questionType ? color(100, 60, 160) : 80);
        text(questionTypes[i], dbX + dbW/2, itemY + itemH/2);
      }
    }

    function drawEquationArea() {
      textAlign(CENTER, CENTER); textSize(52);
      textFont('Poppins'); fill(40);
      
      if (mode === 'challenge') {
        let eqStr = '';
        if (questionType === 'Distributive') {
          eqStr = distributiveA + '(x + ' + distributiveB + ') = ' + targetC;
        } else {
          let aStr = targetA === 1 ? 'x' : targetA + 'x';
          if (targetB === 0) {
            eqStr = aStr + ' = ' + targetC;
          } else if (targetB > 0) {
            eqStr = aStr + ' + ' + targetB + ' = ' + targetC;
          } else {
            eqStr = aStr + ' + (' + targetB + ') = ' + targetC;
          }
        }
        text(eqStr, CENTER_X, EQUATION_Y);
        
        if (phase === 'build' && !(leftMatch && rightMatch)) {
          fill(140); textSize(16);
          text('Set up the problem:', CENTER_X, EQUATION_Y + 42);
        }
        
        if (leftMatch && rightMatch && phase === 'build') {
          drawCheckmark(710, EQUATION_Y, 1.2, color(34, 197, 94));
          drawCheckmark(760, EQUATION_Y, 1.2, color(34, 197, 94));
        }
        
        if (phase === 'solved') {
          drawCheckmark(690, EQUATION_Y, 1.2, color(34, 197, 94));
          drawCheckmark(740, EQUATION_Y, 1.2, color(34, 197, 94));
          drawCheckmark(790, EQUATION_Y, 1.2, color(34, 197, 94));
        }
      } else {
        let leftEq = buildSideEq(leftSide);
        let rightEq = buildSideEq(rightSide);
        if (leftEq || rightEq) {
          fill(60); text((leftEq || '?') + ' = ' + (rightEq || '?'), CENTER_X, EQUATION_Y);
          if (phase === 'solved') drawCheckmark(770, EQUATION_Y, 1.2, color(34, 197, 94));
        }
      }
    }
    
    function drawCheckmark(x, y, scale, col) {
      push(); translate(x, y);
      stroke(col); strokeWeight(5 * scale); noFill();
      beginShape();
      vertex(-14 * scale, 0);
      vertex(-4 * scale, 10 * scale);
      vertex(14 * scale, -10 * scale);
      endShape(); pop();
    }

    function drawSolveSteps() {
      if (solveSteps.length === 0) return;
      textAlign(CENTER, CENTER); textFont('Poppins'); textSize(28);
      let y = STEPS_START_Y;
      for (let step of solveSteps) {
        fill(50); text(step.left + ' = ' + step.right, CENTER_X, y);
        y += 38;
      }
    }

    function drawBalance() {
      let leftOffset = balanceTilt * balanceTiltMax;
      let rightOffset = -balanceTilt * balanceTiltMax;
      
      fill(30); noStroke();
      triangle(CENTER_X, BALANCE_BEAM_Y + 8, CENTER_X - 35, BALANCE_BEAM_Y + 55, CENTER_X + 35, BALANCE_BEAM_Y + 55);
      fill(255); textSize(24); textAlign(CENTER, CENTER);
      
      if (phase === 'solve' && showWrongAnswer) {
        fill(255, 100, 100);
        text("≠", CENTER_X, BALANCE_BEAM_Y + 35);
      } else if (phase === 'solved') {
        fill(100, 255, 100);
        text("=", CENTER_X, BALANCE_BEAM_Y + 35);
      } else {
        fill(255);
        text("=", CENTER_X, BALANCE_BEAM_Y + 35);
      }
      
      stroke(30); strokeWeight(3);
      line(LEFT_EDGE, BALANCE_BEAM_Y + leftOffset, CENTER_X - 35, BALANCE_BEAM_Y + leftOffset * 0.3);
      line(CENTER_X + 35, BALANCE_BEAM_Y + rightOffset * 0.3, RIGHT_EDGE, BALANCE_BEAM_Y + rightOffset);
      
      fill(170); noStroke(); textSize(13); textFont('Poppins');
      text('LEFT', LEFT_CENTER, BALANCE_BEAM_Y + 18 + leftOffset * 0.6);
      text('RIGHT', RIGHT_CENTER, BALANCE_BEAM_Y + 18 + rightOffset * 0.6);
    }
    
    function drawZeroOutButton() {
      if (zeroOutAnimating) return;
      let hasZero = (leftSide.positiveCubes > 0 && leftSide.negativeCubes < 0) ||
                    (rightSide.positiveCubes > 0 && rightSide.negativeCubes < 0);
      if (hasZero) {
        let btnX = CENTER_X, btnY = BALANCE_BEAM_Y - 30;
        if (zeroOutHover) { fill(100, 60, 160); noStroke(); }
        else { fill(245); stroke(200); strokeWeight(1); }
        rect(btnX - 50, btnY - 14, 100, 28, 14);
        fill(zeroOutHover ? 255 : 100); noStroke();
        textSize(12); textFont('Poppins'); textAlign(CENTER, CENTER);
        text('ZERO OUT', btnX, btnY);
      }
    }
    
    function drawEquationDisplay() {
      let showSubstitution = (phase === 'solve' || phase === 'solved') && xValue !== null;
      let leftEq = buildSideEq(leftSide, showSubstitution ? xValue : null);
      let rightEq = buildSideEq(rightSide, showSubstitution ? xValue : null);
      if (leftEq === '' && rightEq === '') return;
      
      let leftOffset = balanceTilt * balanceTiltMax * 0.5;
      let rightOffset = -balanceTilt * balanceTiltMax * 0.5;
      
      textSize(32); textFont('Poppins'); textAlign(CENTER, CENTER);
      
      fill(60); text(leftEq || '0', LEFT_CENTER, EQUATION_DISPLAY_Y + leftOffset);
      if (mode === 'challenge' && leftMatch && phase === 'build') {
        drawCheckmark(345, EQUATION_DISPLAY_Y + leftOffset, 0.8, color(34, 197, 94));
      }
      
      let showEquals = false;
      if (mode === 'build') {
        showEquals = true;
      } else if (phase === 'build') {
        showEquals = leftMatch && rightMatch;
      } else if (phase === 'solve') {
        showEquals = equationBalanced;
      } else if (phase === 'solved') {
        showEquals = true;
      }
      
      if (showEquals) {
        if (phase === 'solve' && showWrongAnswer) {
          fill(200, 80, 80); text('≠', CENTER_X, EQUATION_DISPLAY_Y);
        } else if (phase === 'solved') {
          fill(34, 197, 94); text('=', CENTER_X, EQUATION_DISPLAY_Y);
        } else {
          fill(140); text('=', CENTER_X, EQUATION_DISPLAY_Y);
        }
      }
      
      fill(60); text(rightEq || '0', RIGHT_CENTER, EQUATION_DISPLAY_Y + rightOffset);
      if (mode === 'challenge' && rightMatch && phase === 'build') {
        drawCheckmark(555, EQUATION_DISPLAY_Y + rightOffset, 0.8, color(34, 197, 94));
      }
    }
    
    function buildSideEq(side, substituteX = null) {
      let parts = [];
      if (side.cups > 0) {
        if (substituteX !== null) {
          let xStr = '(' + substituteX + ')';
          parts.push(side.cups === 1 ? xStr : side.cups + xStr);
        } else {
          parts.push(side.cups === 1 ? 'x' : side.cups + 'x');
        }
      }
      if (side.positiveCubes > 0) {
        parts.push((parts.length > 0 ? '+ ' : '') + side.positiveCubes);
      }
      if (side.negativeCubes < 0) {
        if (parts.length > 0) parts.push('+ (' + side.negativeCubes + ')');
        else parts.push('' + side.negativeCubes);
      }
      return parts.join(' ');
    }

    function drawElementsOnBalance() {
      let leftOffset = balanceTilt * balanceTiltMax * 0.6;
      let rightOffset = -balanceTilt * balanceTiltMax * 0.6;
      
      for (let cup of cups) {
        if (cup !== selectedElement && cup !== mirrorElement) {
          let yOff = cup.side === 'left' ? leftOffset : (cup.side === 'right' ? rightOffset : 0);
          drawCup(cup.x, cup.y + yOff, 75, 65);
          if ((phase === 'solve' || phase === 'solved') && xValue !== null && xValue !== 0) {
            drawCubesInCup(cup, yOff);
          }
        }
      }
      for (let cube of cubes) {
        if (cube !== selectedElement && cube !== mirrorElement && !cube.zeroingOut) {
          let yOff = cube.side === 'left' ? leftOffset : (cube.side === 'right' ? rightOffset : 0);
          drawCubeUnit(cube.x, cube.y + yOff, cube.value);
        }
      }
    }
    
    function drawCubesInCup(cup, yOffset) {
      let size = 14, cols = 3;
      let absVal = Math.abs(xValue);
      let col = xValue > 0 ? 'green' : 'black';
      let startX = cup.x - (cols * size) / 2 + size/2;
      let startY = cup.y + yOffset + 22;
      
      for (let i = 0; i < absVal; i++) {
        let row = floor(i / cols);
        let c = i % cols;
        drawSingleCube(startX + c * (size + 2), startY - row * (size + 2), size, col);
      }
    }
    
    function getCubesInCupPositions(cup) {
      if (xValue === null || xValue === 0) return [];
      let positions = [];
      let size = 14, cols = 3;
      let absVal = Math.abs(xValue);
      let startX = cup.x - (cols * size) / 2 + size/2;
      let startY = cup.y + 22;
      for (let i = 0; i < absVal; i++) {
        let row = floor(i / cols), c = i % cols;
        positions.push({
          x: startX + c * (size + 2),
          y: startY - row * (size + 2),
          size: size
        });
      }
      return positions;
    }
    
    function drawCup(x, y, w, h) {
      fill(235, 245, 255, 200); stroke(170, 195, 220); strokeWeight(2);
      beginShape();
      vertex(x - w/2, y - h/2); vertex(x + w/2, y - h/2);
      vertex(x + w/2 * 0.82, y + h/2); vertex(x - w/2 * 0.82, y + h/2);
      endShape(CLOSE);
      stroke(190, 210, 230); strokeWeight(1);
      line(x - w/2, y - h/2, x + w/2, y - h/2);
    }
    
    function drawCubeUnit(x, y, value) {
      let size = 22, absVal = Math.abs(value);
      let col = value > 0 ? 'green' : 'black';
      if (absVal === 1) drawSingleCube(x, y, size, col);
      else if (absVal === 3) {
        drawSingleCube(x - size - 2, y, size, col);
        drawSingleCube(x, y, size, col);
        drawSingleCube(x + size + 2, y, size, col);
      } else if (absVal === 9) {
        let s = size - 2;
        for (let r = 0; r < 3; r++) for (let c = 0; c < 3; c++)
          drawSingleCube(x + (c - 1) * (s + 1), y + (r - 1) * (s + 1), s, col);
      }
    }
    
    function drawSingleCube(x, y, size, col) {
      let s = size, off = s * 0.22;
      if (col === 'green') {
        fill(0, 105, 0); noStroke();
        quad(x+s/2, y-s/2+off, x+s/2+off, y-s/2, x+s/2+off, y+s/2, x+s/2, y+s/2+off);
        fill(0, 175, 0);
        quad(x-s/2, y-s/2+off, x-s/2+off, y-s/2, x+s/2+off, y-s/2, x+s/2, y-s/2+off);
        fill(0, 140, 0); stroke(0, 95, 0); strokeWeight(1);
        rect(x - s/2, y - s/2 + off, s, s);
      } else {
        fill(50); noStroke();
        quad(x+s/2, y-s/2+off, x+s/2+off, y-s/2, x+s/2+off, y+s/2, x+s/2, y+s/2+off);
        fill(100);
        quad(x-s/2, y-s/2+off, x-s/2+off, y-s/2, x+s/2+off, y-s/2, x+s/2, y-s/2+off);
        fill(70); stroke(40); strokeWeight(1);
        rect(x - s/2, y - s/2 + off, s, s);
      }
    }
    
    function drawDraggedElement(elem) {
      if (elem.type === 'cup') drawCup(elem.x, elem.y, 80, 70);
      else drawCubeUnit(elem.x, elem.y, elem.value);
      
      // Also draw mirror element if exists
      if (mirrorElement) {
        if (mirrorElement.type === 'cup') drawCup(mirrorElement.x, mirrorElement.y, 80, 70);
        else drawCubeUnit(mirrorElement.x, mirrorElement.y, mirrorElement.value);
      }
    }

    function drawButtons() {
      if (phase === 'build' && mode === 'challenge' && leftMatch && rightMatch) {
        let btnX = CENTER_X, btnY = BUTTON_Y;
        fill(solveButtonHover ? color(85, 50, 140) : color(100, 60, 160));
        noStroke(); rect(btnX - 70, btnY - 24, 140, 48, 12);
        fill(255); textSize(18); textFont('Poppins'); textAlign(CENTER, CENTER);
        text('Solve', btnX, btnY);
      }
      
      if (phase === 'build' && mode === 'build' && hasContent()) {
        let btnX = CENTER_X, btnY = BUTTON_Y;
        fill(solveButtonHover ? color(85, 50, 140) : color(100, 60, 160));
        noStroke(); rect(btnX - 70, btnY - 24, 140, 48, 12);
        fill(255); textSize(18); textFont('Poppins'); textAlign(CENTER, CENTER);
        text('Test a Value', btnX, btnY);
      }
      
      if (phase === 'solve' || phase === 'solved') drawXInput();
      
      if (phase === 'solved' && mode === 'challenge') {
        let btnX = 740, btnY = BUTTON_Y;
        fill(nextButtonHover ? color(85, 50, 140) : color(100, 60, 160));
        noStroke(); rect(btnX - 60, btnY - 22, 120, 44, 10);
        fill(255); textSize(14); textFont('Poppins'); textAlign(CENTER, CENTER);
        text('Next Question', btnX, btnY);
      }
    }
    
    function hasContent() {
      return leftSide.cups > 0 || leftSide.positiveCubes > 0 || leftSide.negativeCubes < 0 ||
             rightSide.cups > 0 || rightSide.positiveCubes > 0 || rightSide.negativeCubes < 0;
    }
    
    function drawXInput() {
      let inputX = CENTER_X, inputY = BUTTON_Y;
      fill(60); textSize(28); textFont('Poppins');
      textAlign(RIGHT, CENTER); text('x =', inputX - 50, inputY);
      
      fill(255);
      if (phase === 'solved') { stroke(34, 197, 94); strokeWeight(3); }
      else if (xInputFocused) { stroke(100, 60, 160); strokeWeight(2); }
      else { stroke(190); strokeWeight(1); }
      rect(inputX - 35, inputY - 24, 90, 48, 8);
      
      noStroke(); textAlign(CENTER, CENTER);
      if (xValue !== null) { 
        fill(40); text(xValue, inputX + 10, inputY);
        // Show cursor after the number
        if (xInputFocused && phase === 'solve') {
          let numWidth = textWidth('' + xValue);
          if (floor(cursorBlink / 30) % 2 === 0) {
            stroke(100, 60, 160); strokeWeight(2);
            line(inputX + 10 + numWidth/2 + 4, inputY - 12, inputX + 10 + numWidth/2 + 4, inputY + 12);
          }
        }
      } else if (xInputFocused && phase === 'solve') {
        // Show negative sign if in negative mode
        if (xInputNegative) {
          fill(40); text('-', inputX + 2, inputY);
          if (floor(cursorBlink / 30) % 2 === 0) {
            stroke(100, 60, 160); strokeWeight(2);
            line(inputX + 18, inputY - 12, inputX + 18, inputY + 12);
          }
        } else {
          if (floor(cursorBlink / 30) % 2 === 0) {
            stroke(100, 60, 160); strokeWeight(2);
            line(inputX + 10, inputY - 12, inputX + 10, inputY + 12);
          }
        }
      }
      
      if (phase === 'solve') {
        let qX = inputX + 95, qY = inputY;
        fill(checkHover ? color(100, 60, 160) : 220);
        noStroke(); ellipse(qX, qY, 36, 36);
        fill(checkHover ? 255 : 80);
        textSize(22); textAlign(CENTER, CENTER);
        text('?', qX, qY);
      }
    }

    function drawSourceArea() {
      stroke(230); strokeWeight(1);
      line(LEFT_EDGE + 10, SOURCE_Y - 50, RIGHT_EDGE - 10, SOURCE_Y - 50);
      
      // Cup at far left
      drawCup(LEFT_EDGE + 20, SOURCE_Y, 55, 48);
      fill(150); noStroke(); textSize(10); textFont('Poppins'); textAlign(CENTER);
      text('x', LEFT_EDGE + 20, SOURCE_Y + 38);
      
      // Vertical separator after cup
      stroke(210); strokeWeight(1);
      line(LEFT_EDGE + 70, SOURCE_Y - 30, LEFT_EDGE + 70, SOURCE_Y + 30);
      
      // Sign toggle button
      let toggleX = LEFT_EDGE + 130;
      let toggleW = 70, toggleH = 36;
      
      // Draw toggle background
      if (signMode === 'positive') {
        fill(signToggleHover ? color(0, 150, 0) : color(0, 130, 0));
      } else {
        fill(signToggleHover ? 80 : 60);
      }
      noStroke();
      rect(toggleX - toggleW/2, SOURCE_Y - toggleH/2, toggleW, toggleH, 18);
      
      // Draw toggle label
      fill(255); textSize(16); textFont('Poppins'); textAlign(CENTER, CENTER);
      if (signMode === 'positive') {
        text('+ pos', toggleX, SOURCE_Y);
      } else {
        text('− neg', toggleX, SOURCE_Y);
      }
      
      // Cubes - always show 1, 3, 9 but color depends on mode
      // 3-cube centered at CENTER_X
      let srcY = SOURCE_Y - 5;
      let cubeCol = signMode === 'positive' ? 'green' : 'black';
      let labelCol = signMode === 'positive' ? color(34, 139, 34) : color(60);
      let sign = signMode === 'positive' ? '+' : '−';
      
      let cx = CENTER_X; // 3-cube at center
      
      drawSingleCube(cx - 120, srcY, 20, cubeCol); 
      fill(labelCol); noStroke(); textSize(10); 
      text(sign + '1', cx - 120, srcY + 28);
      
      drawCubeUnit(cx, srcY, signMode === 'positive' ? 3 : -3); 
      fill(labelCol); text(sign + '3', cx, srcY + 38);
      
      drawCubeUnit(cx + 140, srcY, signMode === 'positive' ? 9 : -9); 
      fill(labelCol); text(sign + '9', cx + 140, srcY + 48);
      
      // Clear button at lower right
      let clearX = RIGHT_EDGE - 30, clearY = SOURCE_Y;
      fill(clearButtonHover ? 240 : 250);
      stroke(220); strokeWeight(1);
      rect(clearX - 32, clearY - 14, 64, 28, 14);
      fill(clearButtonHover ? 100 : 150); noStroke();
      textSize(12); textAlign(CENTER, CENTER);
      text('Clear', clearX, clearY);
    }

    function drawZeroOutAnimation() {
      if (!zeroOutAnimating) return;
      
      let p = zeroOutProgress;
      
      for (let pair of zeroOutPairs) {
        if (p < 0.5) {
          let t = p / 0.5;
          let x1 = lerp(pair.gx, pair.mx - 14, t);
          let x2 = lerp(pair.bx, pair.mx + 14, t);
          let y1 = lerp(pair.gy, pair.my, t);
          let y2 = lerp(pair.by, pair.my, t);
          drawSingleCube(x1, y1, 22, 'green');
          drawSingleCube(x2, y2, 22, 'black');
        } else if (p < 0.85) {
          let t = (p - 0.5) / 0.35;
          let dropY = lerp(pair.my, SOURCE_Y, t);
          drawSingleCube(pair.mx - 14, dropY, 22, 'green');
          drawSingleCube(pair.mx + 14, dropY, 22, 'black');
        }
      }
    }
    
    function startZeroOut() {
      zeroOutAnimating = true;
      zeroOutProgress = 0;
      zeroOutPairs = [];
      
      for (let side of ['left', 'right']) {
        let sideCubes = cubes.filter(c => c.side === side);
        let posTotal = sideCubes.filter(c => c.value > 0).reduce((s, c) => s + c.value, 0);
        let negTotal = Math.abs(sideCubes.filter(c => c.value < 0).reduce((s, c) => s + c.value, 0));
        
        if (posTotal === 0 || negTotal === 0) continue;
        
        let toCancel = min(posTotal, negTotal);
        
        let posCubes = sideCubes.filter(c => c.value > 0).slice();
        let negCubes = sideCubes.filter(c => c.value < 0).slice();
        
        posCubes.sort((a, b) => a.value - b.value);
        negCubes.sort((a, b) => Math.abs(a.value) - Math.abs(b.value));
        
        let posRemaining = toCancel;
        let negRemaining = toCancel;
        
        let posToRemove = [];
        let negToRemove = [];
        
        for (let cube of posCubes) {
          if (posRemaining <= 0) break;
          
          if (cube.value <= posRemaining) {
            cube.zeroingOut = true;
            for (let i = 0; i < cube.value; i++) {
              posToRemove.push({ x: cube.x + random(-10, 10), y: cube.y + random(-10, 10) });
            }
            posRemaining -= cube.value;
          } else {
            let removeCount = posRemaining;
            let keepCount = cube.value - removeCount;
            let origX = cube.x, origY = cube.y;
            let origValue = cube.value;
            let isPositive = cube.value > 0;
            
            let idx = cubes.indexOf(cube);
            if (idx > -1) cubes.splice(idx, 1);
            
            let keepPositions = getBlockPositions(origX, origY, origValue);
            for (let i = 0; i < keepCount; i++) {
              let pos = keepPositions[i];
              cubes.push({ type: 'cube', x: pos.x, y: pos.y, side: side, value: isPositive ? 1 : -1 });
            }
            
            for (let i = keepCount; i < origValue; i++) {
              let pos = keepPositions[i];
              posToRemove.push({ x: pos.x, y: pos.y });
            }
            
            posRemaining = 0;
          }
        }
        
        for (let cube of negCubes) {
          if (negRemaining <= 0) break;
          
          let absVal = Math.abs(cube.value);
          
          if (absVal <= negRemaining) {
            cube.zeroingOut = true;
            for (let i = 0; i < absVal; i++) {
              negToRemove.push({ x: cube.x + random(-10, 10), y: cube.y + random(-10, 10) });
            }
            negRemaining -= absVal;
          } else {
            let removeCount = negRemaining;
            let keepCount = absVal - removeCount;
            let origX = cube.x, origY = cube.y;
            let origAbsValue = absVal;
            
            let idx = cubes.indexOf(cube);
            if (idx > -1) cubes.splice(idx, 1);
            
            let keepPositions = getBlockPositions(origX, origY, origAbsValue);
            for (let i = 0; i < keepCount; i++) {
              let pos = keepPositions[i];
              cubes.push({ type: 'cube', x: pos.x, y: pos.y, side: side, value: -1 });
            }
            
            for (let i = keepCount; i < origAbsValue; i++) {
              let pos = keepPositions[i];
              negToRemove.push({ x: pos.x, y: pos.y });
            }
            
            negRemaining = 0;
          }
        }
        
        let pairCount = min(posToRemove.length, negToRemove.length);
        for (let i = 0; i < pairCount; i++) {
          let p = posToRemove[i];
          let n = negToRemove[i];
          zeroOutPairs.push({
            gx: p.x, gy: p.y,
            bx: n.x, by: n.y,
            mx: (p.x + n.x) / 2,
            my: (p.y + n.y) / 2
          });
        }
      }
    }
    
    function getBlockPositions(x, y, absValue) {
      let positions = [];
      let size = 22;
      
      if (absValue === 1) {
        positions.push({ x: x, y: y });
      } else if (absValue === 3) {
        positions.push({ x: x - size - 2, y: y });
        positions.push({ x: x, y: y });
        positions.push({ x: x + size + 2, y: y });
      } else if (absValue === 9) {
        let s = size - 2;
        for (let r = 0; r < 3; r++) {
          for (let c = 0; c < 3; c++) {
            positions.push({ x: x + (c - 1) * (s + 1), y: y + (r - 1) * (s + 1) });
          }
        }
      }
      return positions;
    }
    
    function splitBlockIntoIndividualCubes(cube, side) {
      let absVal = Math.abs(cube.value);
      if (absVal === 1) return;
      
      let positions = getBlockPositions(cube.x, cube.y, absVal);
      let unitValue = cube.value > 0 ? 1 : -1;
      
      let idx = cubes.indexOf(cube);
      if (idx > -1) cubes.splice(idx, 1);
      
      for (let pos of positions) {
        cubes.push({ 
          type: 'cube', 
          x: pos.x, 
          y: pos.y, 
          side: side, 
          value: unitValue,
          solvePaired: cube.solvePaired,
          pairId: cube.pairId
        });
      }
    }
    
    function finishZeroOut() {
      cubes = cubes.filter(c => !c.zeroingOut);
      zeroOutAnimating = false;
      zeroOutPairs = [];
      recalcSides();
      
      equationBalanced = true;
      
      if (phase === 'solve') updateSolveStep();
    }

    function drawFadingElements() {
      for (let elem of fadingElements) {
        if (elem.type === 'cup') {
          fill(235, 245, 255, elem.alpha * 0.8);
          stroke(170, 195, 220, elem.alpha); strokeWeight(2);
          beginShape();
          vertex(elem.x - 37, elem.y - 32); vertex(elem.x + 37, elem.y - 32);
          vertex(elem.x + 30, elem.y + 32); vertex(elem.x - 30, elem.y + 32);
          endShape(CLOSE);
        }
      }
    }
    
    function updateAnimations() {
      cursorBlink++;
      
      if (showWrongAnswer) {
        if (xValue !== null) {
          let leftVal = leftSide.cups * xValue + leftSide.positiveCubes + leftSide.negativeCubes;
          let rightVal = rightSide.cups * xValue + rightSide.positiveCubes + rightSide.negativeCubes;
          if (leftVal > rightVal) {
            balanceTiltTarget = 1;
          } else if (rightVal > leftVal) {
            balanceTiltTarget = -1;
          } else {
            balanceTiltTarget = 0;
          }
        }
      } else {
        balanceTiltTarget = 0;
      }
      
      balanceTilt += (balanceTiltTarget - balanceTilt) * 0.15;
      if (abs(balanceTilt - balanceTiltTarget) < 0.01) balanceTilt = balanceTiltTarget;
      
      if (showWrongAnswer) {
        wrongAnswerTimer++;
        if (wrongAnswerTimer > 90) {
          showWrongAnswer = false;
          wrongAnswerTimer = 0;
        }
      }
      for (let i = fadingElements.length - 1; i >= 0; i--) {
        fadingElements[i].alpha -= 15;
        if (fadingElements[i].alpha <= 0) fadingElements.splice(i, 1);
      }
      if (zeroOutAnimating) {
        zeroOutProgress += 0.02;
        if (zeroOutProgress >= 1) finishZeroOut();
      }
    }

    function getCubeRadius(value) {
      let absVal = Math.abs(value);
      if (absVal === 9) return 45;
      if (absVal === 3) return 42;
      return 22;
    }

    function canPlaceCupAt(x, y) {
      const CUP_RADIUS = 45;
      for (let cube of cubes) {
        let cubeRadius = getCubeRadius(cube.value);
        if (dist(x, y, cube.x, cube.y) < CUP_RADIUS + cubeRadius) return false;
      }
      return true;
    }

    function mousePressed() {
      let mx = mouseX, my = mouseY;
      
      // Close dropdown if clicking elsewhere
      if (dropdownOpen) {
        let dbX = LEFT_EDGE - 17, dbW = 130, itemH = 28;
        let startY = DROPDOWN_Y + 28;
        let dropdownH = questionTypes.length * itemH;
        
        if (mx > dbX && mx < dbX + dbW && my > startY && my < startY + dropdownH) {
          let clickedIndex = floor((my - startY) / itemH);
          if (clickedIndex >= 0 && clickedIndex < questionTypes.length) {
            questionType = questionTypes[clickedIndex];
            generateNewProblem();
          }
        }
        dropdownOpen = false;
        return;
      }
      
      if (my > TABS_Y && my < TABS_Y + 32) {
        if (mx > LEFT_EDGE - 17 && mx < LEFT_EDGE + 83 && mode !== 'challenge') { mode = 'challenge'; generateNewProblem(); return; }
        if (mx > 165 && mx < 305 && mode !== 'build') { mode = 'build'; generateNewProblem(); return; }
        if (mx > 744 && mx < 859) { generateNewProblem(); return; }
      }
      
      // Dropdown button
      if (mode === 'challenge' && mx > LEFT_EDGE - 17 && mx < LEFT_EDGE + 113 && my > DROPDOWN_Y && my < DROPDOWN_Y + 24) {
        dropdownOpen = !dropdownOpen;
        return;
      }
      
      // Sign toggle button
      let toggleX = LEFT_EDGE + 130;
      let toggleW = 70, toggleH = 36;
      if (mx > toggleX - toggleW/2 && mx < toggleX + toggleW/2 && my > SOURCE_Y - toggleH/2 && my < SOURCE_Y + toggleH/2) {
        signMode = signMode === 'positive' ? 'negative' : 'positive';
        return;
      }
      
      // Clear button
      if (mx > RIGHT_EDGE - 62 && mx < RIGHT_EDGE + 2 && my > SOURCE_Y - 14 && my < SOURCE_Y + 14) {
        clearBalance(); return;
      }
      
      if (phase === 'solved' && mode === 'challenge' && mx > 680 && mx < 800 && my > BUTTON_Y - 22 && my < BUTTON_Y + 22) {
        generateNewProblem(); return;
      }
      
      if (phase === 'solve' && xValue !== null) {
        let qX = CENTER_X + 95, qY = BUTTON_Y;
        if (dist(mx, my, qX, qY) < 20) { checkAnswer(); return; }
      }
      
      if ((phase === 'solve' || phase === 'solved') && mx > CENTER_X - 35 && mx < CENTER_X + 55 && my > BUTTON_Y - 24 && my < BUTTON_Y + 24) {
        xInputFocused = true; return;
      } else xInputFocused = false;
      
      let hasZero = (leftSide.positiveCubes > 0 && leftSide.negativeCubes < 0) ||
                    (rightSide.positiveCubes > 0 && rightSide.negativeCubes < 0);
      if (hasZero && !zeroOutAnimating && mx > CENTER_X - 50 && mx < CENTER_X + 50 && my > BALANCE_BEAM_Y - 44 && my < BALANCE_BEAM_Y - 16) {
        startZeroOut(); return;
      }
      
      if (phase === 'build') {
        let canSolve = (mode === 'challenge' && leftMatch && rightMatch) || (mode === 'build' && hasContent());
        if (canSolve && mx > CENTER_X - 70 && mx < CENTER_X + 70 && my > BUTTON_Y - 24 && my < BUTTON_Y + 24) {
          startSolveMode(); return;
        }
      }
      
      if ((phase === 'solve' || phase === 'solved') && xValue !== null && xValue !== 0) {
        for (let cup of cups) {
          let cubePositions = getCubesInCupPositions(cup);
          for (let pos of cubePositions) {
            if (dist(mx, my, pos.x, pos.y) < pos.size / 2 + 4) {
              let newCubeValue = xValue > 0 ? 1 : -1;
              selectedElement = { 
                type: 'cube', 
                x: mx, 
                y: my, 
                side: null, 
                value: newCubeValue, 
                isNew: true,
                fromCup: true 
              };
              cubes.push(selectedElement);
              dragOffsetX = 0;
              dragOffsetY = 0;
              
              if (xValue > 0) xValue--;
              else xValue++;
              if (xValue === 0) xValue = null;
              
              equationBalanced = false;
              
              return;
            }
          }
        }
      }
      
      for (let cup of cups) {
        if (dist(mx, my, cup.x, cup.y) < 42) {
          selectedElement = cup;
          dragOffsetX = cup.x - mx; dragOffsetY = cup.y - my;
          
          // Find matching element on other side during solve phase
          if (phase === 'solve' && mode === 'challenge' && cup.side) {
            let otherSide = cup.side === 'left' ? 'right' : 'left';
            // Try to find existing pair or match
            if (cup.solvePaired && cup.pairId) {
              mirrorElement = cup.pairId;
            } else {
              mirrorElement = cups.find(c => c.side === otherSide && c !== cup && !c.sprouted);
              if (mirrorElement) {
                // Link them as a pair
                cup.solvePaired = true;
                cup.pairId = mirrorElement;
                mirrorElement.solvePaired = true;
                mirrorElement.pairId = cup;
              }
            }
          } else {
            mirrorElement = null;
          }
          return;
        }
      }
      
      for (let cube of cubes) {
        let hitR = getCubeRadius(cube.value);
        if (dist(mx, my, cube.x, cube.y) < hitR) {
          selectedElement = cube;
          dragOffsetX = cube.x - mx; dragOffsetY = cube.y - my;
          
          // Find matching element on other side during solve phase
          if (phase === 'solve' && mode === 'challenge' && cube.side) {
            let otherSide = cube.side === 'left' ? 'right' : 'left';
            // Try to find existing pair or match with same value
            if (cube.solvePaired && cube.pairId) {
              mirrorElement = cube.pairId;
            } else {
              mirrorElement = cubes.find(c => c.side === otherSide && c.value === cube.value && c !== cube && !c.sprouted);
              if (mirrorElement) {
                // Link them as a pair
                cube.solvePaired = true;
                cube.pairId = mirrorElement;
                mirrorElement.solvePaired = true;
                mirrorElement.pairId = cube;
              }
            }
          } else {
            mirrorElement = null;
          }
          return;
        }
      }
      
      // Source elements - no mirror for new elements
      mirrorElement = null;
      
      // Cup
      if (dist(mx, my, LEFT_EDGE + 20, SOURCE_Y) < 35) {
        selectedElement = { type: 'cup', x: mx, y: my, side: null, isNew: true };
        cups.push(selectedElement); return;
      }
      
      // Cubes based on sign mode (3-cube centered at CENTER_X)
      let cx = CENTER_X;
      let srcY = SOURCE_Y - 5;
      let signMult = signMode === 'positive' ? 1 : -1;
      
      // 1-cube
      if (dist(mx, my, cx - 120, srcY) < 20) {
        selectedElement = { type: 'cube', x: mx, y: my, side: null, value: 1 * signMult, isNew: true };
        cubes.push(selectedElement); return;
      }
      // 3-cube
      if (dist(mx, my, cx, srcY) < 40) {
        selectedElement = { type: 'cube', x: mx, y: my, side: null, value: 3 * signMult, isNew: true };
        cubes.push(selectedElement); return;
      }
      // 9-cube
      if (dist(mx, my, cx + 140, srcY) < 45) {
        selectedElement = { type: 'cube', x: mx, y: my, side: null, value: 9 * signMult, isNew: true };
        cubes.push(selectedElement); return;
      }
    }
    
    function mouseDragged() {
      if (selectedElement) {
        selectedElement.x = mouseX + dragOffsetX;
        selectedElement.y = mouseY + dragOffsetY;
        
        // Mirror the movement for the paired element
        if (mirrorElement) {
          // Mirror x position across center
          mirrorElement.x = CENTER_X + (CENTER_X - selectedElement.x);
          mirrorElement.y = selectedElement.y;
        }
      }
    }
    
    function mouseReleased() {
      if (!selectedElement) return;
      let elem = selectedElement;
      let mirror = mirrorElement;
      selectedElement = null;
      mirrorElement = null;
      
      let onBalance = elem.y < BALANCE_BEAM_Y - 20 && elem.y > 150;
      let onLeft = elem.x > LEFT_EDGE && elem.x < CENTER_X - 35;
      let onRight = elem.x > CENTER_X + 35 && elem.x < RIGHT_EDGE;
      
      if (elem.type === 'cube') {
        let cup = findCupAt(elem.x, elem.y);
        if (cup) {
          if (xValue === null) xValue = elem.value;
          else xValue += elem.value;
          let idx = cubes.indexOf(elem);
          if (idx > -1) cubes.splice(idx, 1);
          
          // Also remove mirror if in solve mode
          if (mirror) {
            let mirrorCup = findCupAt(mirror.x, mirror.y);
            if (mirrorCup) {
              if (xValue === null) xValue = mirror.value;
              else xValue += mirror.value;
            }
            let midx = cubes.indexOf(mirror);
            if (midx > -1) cubes.splice(midx, 1);
          }
          
          equationBalanced = false;
          
          return;
        }
      }
      
      if (onBalance && (onLeft || onRight)) {
        let newSide = onLeft ? 'left' : 'right';
        
        if (elem.type === 'cup') {
          if (!canPlaceCupAt(elem.x, elem.y)) {
            let idx = cups.indexOf(elem);
            if (idx > -1) { fadingElements.push({ ...elem, alpha: 255 }); cups.splice(idx, 1); }
            // Also remove mirror if we had one
            if (mirror) {
              let midx = cups.indexOf(mirror);
              if (midx > -1) cups.splice(midx, 1);
            }
            recalcSides(); checkSetup();
            return;
          }
        }
        
        if (phase === 'solve' && elem.isNew) {
          elem.side = newSide; elem.isNew = false;
          elem.solvePaired = true;
          let mirrorSide = newSide === 'left' ? 'right' : 'left';
          let mirrorX = newSide === 'left' ? elem.x + 440 : elem.x - 440;
          let newMirror;
          if (elem.type === 'cup') {
            newMirror = { type: 'cup', x: mirrorX, y: elem.y, side: mirrorSide, solvePaired: true, pairId: elem };
            cups.push(newMirror);
          } else {
            newMirror = { type: 'cube', x: mirrorX, y: elem.y, side: mirrorSide, value: elem.value, solvePaired: true, pairId: elem };
            cubes.push(newMirror);
            if (Math.abs(elem.value) > 1) {
              splitBlockIntoIndividualCubes(elem, newSide);
              splitBlockIntoIndividualCubes(newMirror, mirrorSide);
            }
          }
          elem.pairId = newMirror;
          recalcSides(); updateSolveStep();
          
          equationBalanced = true;
          
          return;
        }
        
        // Handle paired element - keep both on balance at new positions
        if (mirror && phase === 'solve') {
          let mirrorSide = newSide === 'left' ? 'right' : 'left';
          mirror.x = CENTER_X + (CENTER_X - elem.x);
          mirror.y = elem.y;
          mirror.side = mirrorSide;
          elem.side = newSide;
          recalcSides(); updateSolveStep();
          equationBalanced = true;
          return;
        }
        
        elem.side = newSide; elem.isNew = false;
        
        if (elem.type === 'cube' && Math.abs(elem.value) > 1) {
          splitBlockIntoIndividualCubes(elem, newSide);
        }
        
        recalcSides(); checkSetup();
      } else {
        // Releasing off balance - remove both elements
        if (mirror) {
          if (mirror.type === 'cup') {
            let idx = cups.indexOf(mirror);
            if (idx > -1) cups.splice(idx, 1);
          } else {
            let idx = cubes.indexOf(mirror);
            if (idx > -1) cubes.splice(idx, 1);
          }
        }
        
        if (elem.type === 'cup') {
          let idx = cups.indexOf(elem);
          if (idx > -1) { fadingElements.push({ ...elem, alpha: 255 }); cups.splice(idx, 1); }
        } else {
          let idx = cubes.indexOf(elem);
          if (idx > -1) cubes.splice(idx, 1);
        }
        recalcSides(); checkSetup();
        
        if (phase === 'solve') {
          updateSolveStep();
          equationBalanced = true;
        }
      }
    }
    
    function findCupAt(x, y) {
      for (let cup of cups) if (dist(x, y, cup.x, cup.y) < 50) return cup;
      return null;
    }
    
    function mouseMoved() {
      let canSolve = (mode === 'challenge' && leftMatch && rightMatch) || (mode === 'build' && hasContent());
      solveButtonHover = (phase === 'build' && canSolve && mouseX > CENTER_X - 70 && mouseX < CENTER_X + 70 && mouseY > BUTTON_Y - 24 && mouseY < BUTTON_Y + 24);
      challengeTabHover = (mouseY > TABS_Y && mouseY < TABS_Y + 32 && mouseX > LEFT_EDGE - 17 && mouseX < LEFT_EDGE + 83);
      buildTabHover = (mouseY > TABS_Y && mouseY < TABS_Y + 32 && mouseX > 165 && mouseX < 305);
      newQuestionHover = (mouseY > TABS_Y && mouseY < TABS_Y + 32 && mouseX > 744 && mouseX < 859);
      nextButtonHover = (phase === 'solved' && mode === 'challenge' && mouseX > 680 && mouseX < 800 && mouseY > BUTTON_Y - 22 && mouseY < BUTTON_Y + 22);
      let hasZero = (leftSide.positiveCubes > 0 && leftSide.negativeCubes < 0) || (rightSide.positiveCubes > 0 && rightSide.negativeCubes < 0);
      zeroOutHover = (hasZero && mouseX > CENTER_X - 50 && mouseX < CENTER_X + 50 && mouseY > BALANCE_BEAM_Y - 44 && mouseY < BALANCE_BEAM_Y - 16);
      
      clearButtonHover = (mouseX > RIGHT_EDGE - 62 && mouseX < RIGHT_EDGE + 2 && mouseY > SOURCE_Y - 14 && mouseY < SOURCE_Y + 14);
      
      dropdownButtonHover = (mode === 'challenge' && mouseX > LEFT_EDGE - 17 && mouseX < LEFT_EDGE + 113 && mouseY > DROPDOWN_Y && mouseY < DROPDOWN_Y + 24);
      
      // Sign toggle hover
      let toggleX = LEFT_EDGE + 130;
      let toggleW = 70, toggleH = 36;
      signToggleHover = (mouseX > toggleX - toggleW/2 && mouseX < toggleX + toggleW/2 && mouseY > SOURCE_Y - toggleH/2 && mouseY < SOURCE_Y + toggleH/2);
      
      if (dropdownOpen && mode === 'challenge') {
        let dbX = LEFT_EDGE - 17, dbW = 130, itemH = 28;
        let startY = DROPDOWN_Y + 28;
        if (mouseX > dbX && mouseX < dbX + dbW && mouseY > startY && mouseY < startY + questionTypes.length * itemH) {
          dropdownHoverIndex = floor((mouseY - startY) / itemH);
        } else {
          dropdownHoverIndex = -1;
        }
      } else {
        dropdownHoverIndex = -1;
      }
      
      if (phase === 'solve') {
        let qX = CENTER_X + 95, qY = BUTTON_Y;
        checkHover = dist(mouseX, mouseY, qX, qY) < 20;
      } else checkHover = false;
    }
    
    function keyPressed() {
      if (phase === 'solve' && xInputFocused) {
        if (key === '-') {
          if (xValue === null) {
            xInputNegative = !xInputNegative;
          } else {
            xValue = -xValue;
          }
        } else if (key >= '0' && key <= '9') {
          let d = int(key);
          if (xValue === null) {
            xValue = xInputNegative ? -d : d;
            xInputNegative = false;
          } else if (xValue >= 0) { 
            xValue = xValue * 10 + d; 
            if (xValue > 99) xValue = d; 
          } else { 
            xValue = xValue * 10 - d; 
            if (xValue < -99) xValue = -d; 
          }
          
          equationBalanced = false;
        } else if (keyCode === BACKSPACE) {
          if (xValue !== null) {
            if (Math.abs(xValue) < 10) xValue = null;
            else xValue = floor(xValue / 10);
          } else {
            xInputNegative = false;
          }
          equationBalanced = false;
        } else if (keyCode === ENTER || keyCode === RETURN) {
          if (xValue !== null) checkAnswer();
        }
      }
    }
    
    function checkAnswer() {
      if (xValue === null) return;
      
      if (mode === 'challenge') {
        if (xValue === targetSolution) {
          solveSteps.push({ left: 'x', right: '' + targetSolution });
          phase = 'solved';
          equationBalanced = true;
        } else {
          showWrongAnswer = true;
          wrongAnswerTimer = 0;
        }
      } else {
        let l = leftSide.cups * xValue + leftSide.positiveCubes + leftSide.negativeCubes;
        let r = rightSide.cups * xValue + rightSide.positiveCubes + rightSide.negativeCubes;
        if (l === r) {
          solveSteps.push({ left: 'x', right: '' + xValue });
          phase = 'solved';
          equationBalanced = true;
        } else {
          showWrongAnswer = true;
          wrongAnswerTimer = 0;
        }
      }
    }

    function recalcSides() {
      // Exclude sprouted (temporary) elements from counting
      leftSide.cups = cups.filter(c => c.side === 'left' && !c.sprouted).length;
      leftSide.positiveCubes = cubes.filter(c => c.side === 'left' && c.value > 0 && !c.sprouted).reduce((s, c) => s + c.value, 0);
      leftSide.negativeCubes = cubes.filter(c => c.side === 'left' && c.value < 0 && !c.sprouted).reduce((s, c) => s + c.value, 0);
      rightSide.cups = cups.filter(c => c.side === 'right' && !c.sprouted).length;
      rightSide.positiveCubes = cubes.filter(c => c.side === 'right' && c.value > 0 && !c.sprouted).reduce((s, c) => s + c.value, 0);
      rightSide.negativeCubes = cubes.filter(c => c.side === 'right' && c.value < 0 && !c.sprouted).reduce((s, c) => s + c.value, 0);
    }
    
    function checkSetup() {
      if (mode === 'challenge') {
        let lTotal = leftSide.positiveCubes + leftSide.negativeCubes;
        let rTotal = rightSide.positiveCubes + rightSide.negativeCubes;
        leftMatch = (leftSide.cups === targetA && lTotal === targetB);
        rightMatch = (rightSide.cups === 0 && rTotal === targetC);
      }
    }
    
    function startSolveMode() {
      phase = 'solve'; solveSteps = []; xValue = null; xInputNegative = false; xInputFocused = true;
      showWrongAnswer = false;
      equationBalanced = true;
    }
    
    function updateSolveStep() {
      let l = buildSideEq(leftSide), r = buildSideEq(rightSide);
      solveSteps.push({ left: l, right: r });
      if (solveSteps.length > 4) solveSteps.shift();
    }

    function touchStarted() { mousePressed(); return false; }
    function touchMoved() { mouseDragged(); return false; }
    function touchEnded() { mouseReleased(); return false; }
  </script>
</body>
</html>
