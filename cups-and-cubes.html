<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Algebra Studio Balance Lab</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    body { 
      margin: 0; padding: 20px; min-height: 100vh; 
      background: #f5f5f5; display: flex; flex-direction: column; 
      align-items: center; font-family: 'Poppins', sans-serif;
      -webkit-user-select: none; user-select: none; touch-action: none;
    }
    #canvas-container { 
      position: relative; width: 900px; height: 820px;
      background: white; border-radius: 16px;
      box-shadow: 0 2px 20px rgba(0,0,0,0.08); overflow: hidden;
    }
    canvas { display: block; touch-action: none; }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <script>
    let cups = [];
    let cubes = [];
    let selectedElement = null;
    let dragOffsetX = 0, dragOffsetY = 0;
    let mode = 'challenge';
    let targetA = 2, targetB = 3, targetC = 7, targetSolution = 2;
    let leftSide = { cups: 0, positiveCubes: 0, negativeCubes: 0 };
    let rightSide = { cups: 0, positiveCubes: 0, negativeCubes: 0 };
    let phase = 'build';
    let leftMatch = false, rightMatch = false;
    let xValue = null;
    let solveSteps = [];
    let xInputFocused = false;
    let cursorBlink = 0;
    let showWrongAnswer = false;
    let wrongAnswerTimer = 0;
    let zeroOutAnimating = false;
    let zeroOutPairs = [];
    let zeroOutProgress = 0;
    let fadingElements = [];
    let solveButtonHover = false, clearButtonHover = false;
    let challengeTabHover = false, buildTabHover = false;
    let nextButtonHover = false, zeroOutHover = false, checkHover = false;
    
    const TABS_Y = 25, EQUATION_Y = 70, STEPS_START_Y = 130;
    const BALANCE_BEAM_Y = 500, EQUATION_DISPLAY_Y = 580;
    const BUTTON_Y = 660, SOURCE_Y = 770;

    function setup() {
      let canvas = createCanvas(900, 820);
      canvas.parent('canvas-container');
      generateNewProblem();
    }

    function generateNewProblem() {
      if (mode === 'challenge') {
        targetSolution = floor(random(1, 6));
        targetA = floor(random(1, 5));
        targetB = floor(random(1, 7));
        targetC = targetA * targetSolution + targetB;
      }
      cups = []; cubes = [];
      leftSide = { cups: 0, positiveCubes: 0, negativeCubes: 0 };
      rightSide = { cups: 0, positiveCubes: 0, negativeCubes: 0 };
      phase = 'build'; leftMatch = false; rightMatch = false;
      xValue = null; solveSteps = []; xInputFocused = false;
      showWrongAnswer = false; wrongAnswerTimer = 0;
      zeroOutAnimating = false; zeroOutPairs = [];
    }

    function draw() {
      background(255);
      updateAnimations();
      drawModeTabs();
      drawEquationArea();
      drawSolveSteps();
      drawBalance();
      drawZeroOutButton();
      drawElementsOnBalance();
      drawEquationDisplay();
      drawButtons();
      drawSourceArea();
      if (selectedElement) drawDraggedElement(selectedElement);
      drawFadingElements();
      drawZeroOutAnimation();
    }

    function drawModeTabs() {
      let tabH = 32;
      let challengeX = 25, challengeW = 100;
      if (mode === 'challenge') {
        fill(100, 60, 160); noStroke();
        rect(challengeX, TABS_Y, challengeW, tabH, 16); fill(255);
      } else {
        fill(challengeTabHover ? 240 : 250);
        stroke(220); strokeWeight(1);
        rect(challengeX, TABS_Y, challengeW, tabH, 16); fill(120);
      }
      noStroke(); textSize(13); textFont('Poppins');
      textAlign(CENTER, CENTER);
      text('Challenge', challengeX + challengeW/2, TABS_Y + tabH/2);
      
      let buildX = 135, buildW = 140;
      if (mode === 'build') {
        fill(100, 60, 160); noStroke();
        rect(buildX, TABS_Y, buildW, tabH, 16); fill(255);
      } else {
        fill(buildTabHover ? 240 : 250);
        stroke(220); strokeWeight(1);
        rect(buildX, TABS_Y, buildW, tabH, 16); fill(120);
      }
      noStroke();
      text('Build an Equation', buildX + buildW/2, TABS_Y + tabH/2);
    }

    function drawEquationArea() {
      textAlign(CENTER, CENTER); textSize(52);
      textFont('Poppins'); fill(40);
      
      if (mode === 'challenge') {
        let eqStr = (targetA === 1 ? 'x' : targetA + 'x') + ' + ' + targetB + ' = ' + targetC;
        text(eqStr, 450, EQUATION_Y);
        
        if (leftMatch && rightMatch && phase === 'build') {
          drawCheckmark(700, EQUATION_Y, 1.2, color(34, 197, 94));
          drawCheckmark(750, EQUATION_Y, 1.2, color(34, 197, 94));
        }
        
        if (phase === 'solved') {
          drawCheckmark(680, EQUATION_Y, 1.2, color(34, 197, 94));
          drawCheckmark(730, EQUATION_Y, 1.2, color(34, 197, 94));
          drawCheckmark(780, EQUATION_Y, 1.2, color(34, 197, 94));
        }
      } else {
        // Build mode - show equation if there's content
        let leftEq = buildSideEq(leftSide);
        let rightEq = buildSideEq(rightSide);
        if (leftEq || rightEq) {
          fill(60); text((leftEq || '?') + ' = ' + (rightEq || '?'), 450, EQUATION_Y);
          if (phase === 'solved') drawCheckmark(780, EQUATION_Y, 1.2, color(34, 197, 94));
        }
        // No placeholder text in build mode
      }
    }
    
    function drawCheckmark(x, y, scale, col) {
      push(); translate(x, y);
      stroke(col); strokeWeight(5 * scale); noFill();
      beginShape();
      vertex(-14 * scale, 0);
      vertex(-4 * scale, 10 * scale);
      vertex(14 * scale, -10 * scale);
      endShape(); pop();
    }

    function drawSolveSteps() {
      if (solveSteps.length === 0) return;
      textAlign(CENTER, CENTER); textFont('Poppins'); textSize(28);
      let y = STEPS_START_Y;
      for (let step of solveSteps) {
        fill(50); text(step.left + ' = ' + step.right, 450, y);
        y += 38;
      }
    }

    function drawBalance() {
      fill(30); noStroke();
      triangle(450, BALANCE_BEAM_Y + 8, 415, BALANCE_BEAM_Y + 55, 485, BALANCE_BEAM_Y + 55);
      fill(255); textSize(24); textAlign(CENTER, CENTER);
      
      if (phase === 'solve' && showWrongAnswer) {
        fill(255, 100, 100);
        text("≠", 450, BALANCE_BEAM_Y + 35);
      } else if (phase === 'solved') {
        fill(100, 255, 100);
        text("=", 450, BALANCE_BEAM_Y + 35);
      } else {
        fill(255);
        text("=", 450, BALANCE_BEAM_Y + 35);
      }
      
      stroke(30); strokeWeight(3);
      line(50, BALANCE_BEAM_Y, 415, BALANCE_BEAM_Y);
      line(485, BALANCE_BEAM_Y, 850, BALANCE_BEAM_Y);
      fill(170); noStroke(); textSize(13); textFont('Poppins');
      text('LEFT', 230, BALANCE_BEAM_Y + 18);
      text('RIGHT', 670, BALANCE_BEAM_Y + 18);
    }
    
    function drawZeroOutButton() {
      if (zeroOutAnimating) return;
      let hasZero = (leftSide.positiveCubes > 0 && leftSide.negativeCubes < 0) ||
                    (rightSide.positiveCubes > 0 && rightSide.negativeCubes < 0);
      if (hasZero) {
        let btnX = 450, btnY = BALANCE_BEAM_Y - 30;
        if (zeroOutHover) { fill(100, 60, 160); noStroke(); }
        else { fill(245); stroke(200); strokeWeight(1); }
        rect(btnX - 50, btnY - 14, 100, 28, 14);
        fill(zeroOutHover ? 255 : 100); noStroke();
        textSize(12); textFont('Poppins'); textAlign(CENTER, CENTER);
        text('ZERO OUT', btnX, btnY);
      }
    }
    
    function drawEquationDisplay() {
      let leftEq = buildSideEq(leftSide);
      let rightEq = buildSideEq(rightSide);
      if (leftEq === '' && rightEq === '') return;
      
      textSize(32); textFont('Poppins'); textAlign(CENTER, CENTER);
      
      // Left side
      fill(60); text(leftEq || '0', 230, EQUATION_DISPLAY_Y);
      if (mode === 'challenge' && leftMatch && phase === 'build') {
        drawCheckmark(350, EQUATION_DISPLAY_Y, 0.8, color(34, 197, 94));
      }
      
      // Only show equals sign if both sides match in challenge build mode, or always in other modes
      let showEquals = (mode === 'build') || (phase !== 'build') || (leftMatch && rightMatch);
      
      if (showEquals) {
        if (phase === 'solve' && showWrongAnswer) {
          fill(200, 80, 80); text('≠', 450, EQUATION_DISPLAY_Y);
        } else if (phase === 'solved') {
          fill(34, 197, 94); text('=', 450, EQUATION_DISPLAY_Y);
        } else {
          fill(140); text('=', 450, EQUATION_DISPLAY_Y);
        }
      }
      
      // Right side
      fill(60); text(rightEq || '0', 670, EQUATION_DISPLAY_Y);
      if (mode === 'challenge' && rightMatch && phase === 'build') {
        drawCheckmark(550, EQUATION_DISPLAY_Y, 0.8, color(34, 197, 94));
      }
    }
    
    function buildSideEq(side) {
      let parts = [];
      if (side.cups > 0) parts.push(side.cups === 1 ? 'x' : side.cups + 'x');
      if (side.positiveCubes > 0) {
        parts.push((parts.length > 0 ? '+ ' : '') + side.positiveCubes);
      }
      if (side.negativeCubes < 0) {
        if (parts.length > 0) parts.push('+ (' + side.negativeCubes + ')');
        else parts.push('' + side.negativeCubes);
      }
      return parts.join(' ');
    }

    function drawElementsOnBalance() {
      for (let cup of cups) {
        if (cup !== selectedElement) {
          drawCup(cup.x, cup.y, 75, 65);
          if ((phase === 'solve' || phase === 'solved') && xValue !== null && xValue !== 0) {
            drawCubesInCup(cup);
          }
        }
      }
      for (let cube of cubes) {
        if (cube !== selectedElement && !cube.zeroingOut) {
          drawCubeUnit(cube.x, cube.y, cube.value);
        }
      }
    }
    
    function drawCubesInCup(cup) {
      let size = 14, cols = 3;
      let absVal = Math.abs(xValue);
      let col = xValue > 0 ? 'green' : 'black';
      let startX = cup.x - (cols * size) / 2 + size/2;
      let startY = cup.y + 22;
      for (let i = 0; i < absVal && i < 12; i++) {
        let row = floor(i / cols), c = i % cols;
        drawSingleCube(startX + c * (size + 2), startY - row * (size + 2), size, col);
      }
    }
    
    function drawCup(x, y, w, h) {
      fill(235, 245, 255, 200); stroke(170, 195, 220); strokeWeight(2);
      beginShape();
      vertex(x - w/2, y - h/2); vertex(x + w/2, y - h/2);
      vertex(x + w/2 * 0.82, y + h/2); vertex(x - w/2 * 0.82, y + h/2);
      endShape(CLOSE);
      stroke(190, 210, 230); strokeWeight(1);
      line(x - w/2, y - h/2, x + w/2, y - h/2);
    }
    
    function drawCubeUnit(x, y, value) {
      let size = 22, absVal = Math.abs(value);
      let col = value > 0 ? 'green' : 'black';
      if (absVal === 1) drawSingleCube(x, y, size, col);
      else if (absVal === 3) {
        drawSingleCube(x - size - 2, y, size, col);
        drawSingleCube(x, y, size, col);
        drawSingleCube(x + size + 2, y, size, col);
      } else if (absVal === 9) {
        let s = size - 2;
        for (let r = 0; r < 3; r++) for (let c = 0; c < 3; c++)
          drawSingleCube(x + (c - 1) * (s + 1), y + (r - 1) * (s + 1), s, col);
      }
    }
    
    function drawSingleCube(x, y, size, col) {
      let s = size, off = s * 0.22;
      if (col === 'green') {
        fill(0, 105, 0); noStroke();
        quad(x+s/2, y-s/2+off, x+s/2+off, y-s/2, x+s/2+off, y+s/2, x+s/2, y+s/2+off);
        fill(0, 175, 0);
        quad(x-s/2, y-s/2+off, x-s/2+off, y-s/2, x+s/2+off, y-s/2, x+s/2, y-s/2+off);
        fill(0, 140, 0); stroke(0, 95, 0); strokeWeight(1);
        rect(x - s/2, y - s/2 + off, s, s);
      } else {
        fill(50); noStroke();
        quad(x+s/2, y-s/2+off, x+s/2+off, y-s/2, x+s/2+off, y+s/2, x+s/2, y+s/2+off);
        fill(100);
        quad(x-s/2, y-s/2+off, x-s/2+off, y-s/2, x+s/2+off, y-s/2, x+s/2, y-s/2+off);
        fill(70); stroke(40); strokeWeight(1);
        rect(x - s/2, y - s/2 + off, s, s);
      }
    }
    
    function drawDraggedElement(elem) {
      if (elem.type === 'cup') drawCup(elem.x, elem.y, 80, 70);
      else drawCubeUnit(elem.x, elem.y, elem.value);
    }

    function drawButtons() {
      if (phase === 'build' && mode === 'challenge' && leftMatch && rightMatch) {
        let btnX = 450, btnY = BUTTON_Y;
        fill(solveButtonHover ? color(85, 50, 140) : color(100, 60, 160));
        noStroke(); rect(btnX - 70, btnY - 24, 140, 48, 12);
        fill(255); textSize(18); textFont('Poppins'); textAlign(CENTER, CENTER);
        text('Solve', btnX, btnY);
      }
      
      if (phase === 'build' && mode === 'build' && hasContent()) {
        let btnX = 450, btnY = BUTTON_Y;
        fill(solveButtonHover ? color(85, 50, 140) : color(100, 60, 160));
        noStroke(); rect(btnX - 70, btnY - 24, 140, 48, 12);
        fill(255); textSize(18); textFont('Poppins'); textAlign(CENTER, CENTER);
        text('Test a Value', btnX, btnY);
      }
      
      if (phase === 'solve' || phase === 'solved') drawXInput();
      
      if (phase === 'solved' && mode === 'challenge') {
        let btnX = 750, btnY = BUTTON_Y;
        fill(nextButtonHover ? color(85, 50, 140) : color(100, 60, 160));
        noStroke(); rect(btnX - 65, btnY - 22, 130, 44, 10);
        fill(255); textSize(15); textFont('Poppins'); textAlign(CENTER, CENTER);
        text('Next Question', btnX, btnY);
      }
    }
    
    function hasContent() {
      return leftSide.cups > 0 || leftSide.positiveCubes > 0 || leftSide.negativeCubes < 0 ||
             rightSide.cups > 0 || rightSide.positiveCubes > 0 || rightSide.negativeCubes < 0;
    }
    
    function drawXInput() {
      let inputX = 450, inputY = BUTTON_Y;
      fill(60); textSize(28); textFont('Poppins');
      textAlign(RIGHT, CENTER); text('x =', inputX - 50, inputY);
      
      fill(255);
      if (phase === 'solved') { stroke(34, 197, 94); strokeWeight(3); }
      else if (xInputFocused) { stroke(100, 60, 160); strokeWeight(2); }
      else { stroke(190); strokeWeight(1); }
      rect(inputX - 35, inputY - 24, 90, 48, 8);
      
      noStroke(); textAlign(CENTER, CENTER);
      if (xValue !== null) { fill(40); text(xValue, inputX + 10, inputY); }
      else if (xInputFocused && phase === 'solve') {
        if (floor(cursorBlink / 30) % 2 === 0) {
          stroke(100, 60, 160); strokeWeight(2);
          line(inputX + 10, inputY - 12, inputX + 10, inputY + 12);
        }
      }
      
      if (phase === 'solve' && !xInputFocused && xValue === null) {
        fill(180); textSize(11); text('click to type', inputX + 10, inputY);
      }
      
      if (phase === 'solve') {
        let qX = inputX + 75, qY = inputY;
        fill(checkHover ? color(100, 60, 160) : 220);
        noStroke(); ellipse(qX, qY, 36, 36);
        fill(checkHover ? 255 : 80);
        textSize(22); textAlign(CENTER, CENTER);
        text('?', qX, qY);
      }
    }

    function drawSourceArea() {
      stroke(230); strokeWeight(1);
      line(60, SOURCE_Y - 55, 840, SOURCE_Y - 55);
      
      drawCup(70, SOURCE_Y, 60, 52);
      fill(150); noStroke(); textSize(11); textFont('Poppins'); textAlign(CENTER);
      text('x', 70, SOURCE_Y + 42);
      
      drawSingleCube(150, SOURCE_Y, 22, 'green'); fill(34, 139, 34); text('+1', 150, SOURCE_Y + 42);
      drawCubeUnit(240, SOURCE_Y, 3); fill(34, 139, 34); text('+3', 240, SOURCE_Y + 42);
      drawCubeUnit(360, SOURCE_Y, 9); fill(34, 139, 34); text('+9', 360, SOURCE_Y + 42);
      
      drawSingleCube(500, SOURCE_Y, 22, 'black'); fill(60); text('-1', 500, SOURCE_Y + 42);
      drawCubeUnit(590, SOURCE_Y, -3); fill(60); text('-3', 590, SOURCE_Y + 42);
      drawCubeUnit(710, SOURCE_Y, -9); fill(60); text('-9', 710, SOURCE_Y + 42);
      
      let clearX = 830, clearY = SOURCE_Y;
      fill(clearButtonHover ? 235 : 248); stroke(200); strokeWeight(1);
      rect(clearX - 32, clearY - 18, 64, 36, 8);
      fill(120); noStroke(); textSize(14); textAlign(CENTER, CENTER);
      text('Clear', clearX, clearY);
    }

    function drawZeroOutAnimation() {
      if (!zeroOutAnimating) return;
      
      let p = zeroOutProgress;
      
      for (let pair of zeroOutPairs) {
        if (p < 0.5) {
          // Move toward each other
          let t = p / 0.5;
          let x1 = lerp(pair.gx, pair.mx - 14, t);
          let x2 = lerp(pair.bx, pair.mx + 14, t);
          let y1 = lerp(pair.gy, pair.my, t);
          let y2 = lerp(pair.by, pair.my, t);
          drawSingleCube(x1, y1, 22, 'green');
          drawSingleCube(x2, y2, 22, 'black');
        } else if (p < 0.85) {
          // Kiss and drop
          let t = (p - 0.5) / 0.35;
          let dropY = lerp(pair.my, SOURCE_Y, t);
          drawSingleCube(pair.mx - 14, dropY, 22, 'green');
          drawSingleCube(pair.mx + 14, dropY, 22, 'black');
        }
        // After 0.85, they've dropped out of view
      }
    }
    
    function startZeroOut() {
      zeroOutAnimating = true;
      zeroOutProgress = 0;
      zeroOutPairs = [];
      
      // Process each side
      for (let side of ['left', 'right']) {
        let sideCubes = cubes.filter(c => c.side === side);
        let posTotal = sideCubes.filter(c => c.value > 0).reduce((s, c) => s + c.value, 0);
        let negTotal = Math.abs(sideCubes.filter(c => c.value < 0).reduce((s, c) => s + c.value, 0));
        
        if (posTotal === 0 || negTotal === 0) continue;
        
        let toCancel = min(posTotal, negTotal);
        
        // We need to mark exactly `toCancel` units of positive and negative for removal
        // This may require splitting blocks
        
        let posCubes = sideCubes.filter(c => c.value > 0).slice(); // copy
        let negCubes = sideCubes.filter(c => c.value < 0).slice();
        
        // Sort by value ascending (prefer smaller blocks first)
        posCubes.sort((a, b) => a.value - b.value);
        negCubes.sort((a, b) => Math.abs(a.value) - Math.abs(b.value));
        
        let posRemaining = toCancel;
        let negRemaining = toCancel;
        
        // Track cubes to remove and positions for animation
        let posToRemove = [];
        let negToRemove = [];
        
        // Process positive cubes
        for (let cube of posCubes) {
          if (posRemaining <= 0) break;
          
          if (cube.value <= posRemaining) {
            // Remove entire cube/block
            cube.zeroingOut = true;
            // Add animation positions for each unit
            for (let i = 0; i < cube.value; i++) {
              posToRemove.push({ x: cube.x + random(-10, 10), y: cube.y + random(-10, 10) });
            }
            posRemaining -= cube.value;
          } else {
            // Need to split this block
            let removeCount = posRemaining;
            let keepCount = cube.value - removeCount;
            let origX = cube.x, origY = cube.y;
            let origValue = cube.value;
            let isPositive = cube.value > 0;
            
            // Remove original block from cubes array
            let idx = cubes.indexOf(cube);
            if (idx > -1) cubes.splice(idx, 1);
            
            // Create individual cubes for the portion to KEEP
            let keepPositions = getBlockPositions(origX, origY, origValue);
            for (let i = 0; i < keepCount; i++) {
              let pos = keepPositions[i];
              cubes.push({
                type: 'cube',
                x: pos.x,
                y: pos.y,
                side: side,
                value: isPositive ? 1 : -1
              });
            }
            
            // Add positions for animation (the removed portion)
            for (let i = keepCount; i < origValue; i++) {
              let pos = keepPositions[i];
              posToRemove.push({ x: pos.x, y: pos.y });
            }
            
            posRemaining = 0;
          }
        }
        
        // Process negative cubes
        for (let cube of negCubes) {
          if (negRemaining <= 0) break;
          
          let absVal = Math.abs(cube.value);
          
          if (absVal <= negRemaining) {
            cube.zeroingOut = true;
            for (let i = 0; i < absVal; i++) {
              negToRemove.push({ x: cube.x + random(-10, 10), y: cube.y + random(-10, 10) });
            }
            negRemaining -= absVal;
          } else {
            // Split
            let removeCount = negRemaining;
            let keepCount = absVal - removeCount;
            let origX = cube.x, origY = cube.y;
            let origAbsValue = absVal;
            
            let idx = cubes.indexOf(cube);
            if (idx > -1) cubes.splice(idx, 1);
            
            let keepPositions = getBlockPositions(origX, origY, origAbsValue);
            for (let i = 0; i < keepCount; i++) {
              let pos = keepPositions[i];
              cubes.push({
                type: 'cube',
                x: pos.x,
                y: pos.y,
                side: side,
                value: -1
              });
            }
            
            for (let i = keepCount; i < origAbsValue; i++) {
              let pos = keepPositions[i];
              negToRemove.push({ x: pos.x, y: pos.y });
            }
            
            negRemaining = 0;
          }
        }
        
        // Create animation pairs
        let pairCount = min(posToRemove.length, negToRemove.length);
        for (let i = 0; i < pairCount; i++) {
          let p = posToRemove[i];
          let n = negToRemove[i];
          zeroOutPairs.push({
            gx: p.x, gy: p.y,
            bx: n.x, by: n.y,
            mx: (p.x + n.x) / 2,
            my: (p.y + n.y) / 2
          });
        }
      }
    }
    
    // Get positions for individual cubes within a block
    function getBlockPositions(x, y, absValue) {
      let positions = [];
      let size = 22;
      
      if (absValue === 1) {
        positions.push({ x: x, y: y });
      } else if (absValue === 3) {
        positions.push({ x: x - size - 2, y: y });
        positions.push({ x: x, y: y });
        positions.push({ x: x + size + 2, y: y });
      } else if (absValue === 9) {
        let s = size - 2;
        for (let r = 0; r < 3; r++) {
          for (let c = 0; c < 3; c++) {
            positions.push({ x: x + (c - 1) * (s + 1), y: y + (r - 1) * (s + 1) });
          }
        }
      }
      return positions;
    }
    
    function finishZeroOut() {
      // Remove cubes marked for zeroing
      cubes = cubes.filter(c => !c.zeroingOut);
      zeroOutAnimating = false;
      zeroOutPairs = [];
      recalcSides();
      
      if (phase === 'solve') updateSolveStep();
    }

    function drawFadingElements() {
      for (let elem of fadingElements) {
        if (elem.type === 'cup') {
          fill(235, 245, 255, elem.alpha * 0.8);
          stroke(170, 195, 220, elem.alpha); strokeWeight(2);
          beginShape();
          vertex(elem.x - 37, elem.y - 32); vertex(elem.x + 37, elem.y - 32);
          vertex(elem.x + 30, elem.y + 32); vertex(elem.x - 30, elem.y + 32);
          endShape(CLOSE);
        }
      }
    }
    
    function updateAnimations() {
      cursorBlink++;
      if (showWrongAnswer) {
        wrongAnswerTimer++;
        if (wrongAnswerTimer > 60) {
          showWrongAnswer = false;
          wrongAnswerTimer = 0;
        }
      }
      for (let i = fadingElements.length - 1; i >= 0; i--) {
        fadingElements[i].alpha -= 15;
        if (fadingElements[i].alpha <= 0) fadingElements.splice(i, 1);
      }
      if (zeroOutAnimating) {
        zeroOutProgress += 0.02;
        if (zeroOutProgress >= 1) finishZeroOut();
      }
    }

    function getCubeRadius(value) {
      let absVal = Math.abs(value);
      if (absVal === 9) return 45;
      if (absVal === 3) return 42;
      return 22;
    }

    function canPlaceCupAt(x, y) {
      const CUP_RADIUS = 45;
      for (let cube of cubes) {
        let cubeRadius = getCubeRadius(cube.value);
        if (dist(x, y, cube.x, cube.y) < CUP_RADIUS + cubeRadius) return false;
      }
      return true;
    }

    function mousePressed() {
      let mx = mouseX, my = mouseY;
      
      if (my > TABS_Y && my < TABS_Y + 32) {
        if (mx > 25 && mx < 125 && mode !== 'challenge') { mode = 'challenge'; generateNewProblem(); return; }
        if (mx > 135 && mx < 275 && mode !== 'build') { mode = 'build'; generateNewProblem(); return; }
      }
      
      if (mx > 798 && mx < 862 && my > SOURCE_Y - 18 && my < SOURCE_Y + 18) { clearWithFade(); return; }
      
      if (phase === 'solved' && mode === 'challenge' && mx > 685 && mx < 815 && my > BUTTON_Y - 22 && my < BUTTON_Y + 22) {
        generateNewProblem(); return;
      }
      
      if (phase === 'solve' && xValue !== null) {
        let qX = 450 + 75, qY = BUTTON_Y;
        if (dist(mx, my, qX, qY) < 20) { checkAnswer(); return; }
      }
      
      if ((phase === 'solve' || phase === 'solved') && mx > 415 && mx < 505 && my > BUTTON_Y - 24 && my < BUTTON_Y + 24) {
        xInputFocused = true; return;
      } else xInputFocused = false;
      
      let hasZero = (leftSide.positiveCubes > 0 && leftSide.negativeCubes < 0) ||
                    (rightSide.positiveCubes > 0 && rightSide.negativeCubes < 0);
      if (hasZero && !zeroOutAnimating && mx > 400 && mx < 500 && my > BALANCE_BEAM_Y - 44 && my < BALANCE_BEAM_Y - 16) {
        startZeroOut(); return;
      }
      
      if (phase === 'build') {
        let canSolve = (mode === 'challenge' && leftMatch && rightMatch) || (mode === 'build' && hasContent());
        if (canSolve && mx > 380 && mx < 520 && my > BUTTON_Y - 24 && my < BUTTON_Y + 24) {
          startSolveMode(); return;
        }
      }
      
      for (let cup of cups) {
        if (dist(mx, my, cup.x, cup.y) < 42) {
          selectedElement = cup;
          dragOffsetX = cup.x - mx; dragOffsetY = cup.y - my;
          return;
        }
      }
      for (let cube of cubes) {
        let hitR = getCubeRadius(cube.value);
        if (dist(mx, my, cube.x, cube.y) < hitR) {
          selectedElement = cube;
          dragOffsetX = cube.x - mx; dragOffsetY = cube.y - my;
          return;
        }
      }
      
      // Source elements
      if (dist(mx, my, 70, SOURCE_Y) < 38) {
        selectedElement = { type: 'cup', x: mx, y: my, side: null, isNew: true };
        cups.push(selectedElement); return;
      }
      if (dist(mx, my, 150, SOURCE_Y) < 22) {
        selectedElement = { type: 'cube', x: mx, y: my, side: null, value: 1, isNew: true };
        cubes.push(selectedElement); return;
      }
      if (dist(mx, my, 240, SOURCE_Y) < 42) {
        selectedElement = { type: 'cube', x: mx, y: my, side: null, value: 3, isNew: true };
        cubes.push(selectedElement); return;
      }
      if (dist(mx, my, 360, SOURCE_Y) < 50) {
        selectedElement = { type: 'cube', x: mx, y: my, side: null, value: 9, isNew: true };
        cubes.push(selectedElement); return;
      }
      if (dist(mx, my, 500, SOURCE_Y) < 22) {
        selectedElement = { type: 'cube', x: mx, y: my, side: null, value: -1, isNew: true };
        cubes.push(selectedElement); return;
      }
      if (dist(mx, my, 590, SOURCE_Y) < 42) {
        selectedElement = { type: 'cube', x: mx, y: my, side: null, value: -3, isNew: true };
        cubes.push(selectedElement); return;
      }
      if (dist(mx, my, 710, SOURCE_Y) < 50) {
        selectedElement = { type: 'cube', x: mx, y: my, side: null, value: -9, isNew: true };
        cubes.push(selectedElement); return;
      }
    }
    
    function mouseDragged() {
      if (selectedElement) {
        selectedElement.x = mouseX + dragOffsetX;
        selectedElement.y = mouseY + dragOffsetY;
      }
    }
    
    function mouseReleased() {
      if (!selectedElement) return;
      let elem = selectedElement;
      selectedElement = null;
      
      let onBalance = elem.y < BALANCE_BEAM_Y - 20 && elem.y > 150;
      let onLeft = elem.x > 50 && elem.x < 415;
      let onRight = elem.x > 485 && elem.x < 850;
      
      // Check drop in cup (for x value)
      if (elem.type === 'cube') {
        let cup = findCupAt(elem.x, elem.y);
        if (cup) {
          if (xValue === null) xValue = elem.value;
          else xValue += elem.value;
          let idx = cubes.indexOf(elem);
          if (idx > -1) cubes.splice(idx, 1);
          return;
        }
      }
      
      if (onBalance && (onLeft || onRight)) {
        let newSide = onLeft ? 'left' : 'right';
        
        // Cup placement - check exclusion zones
        if (elem.type === 'cup') {
          if (!canPlaceCupAt(elem.x, elem.y)) {
            let idx = cups.indexOf(elem);
            if (idx > -1) { fadingElements.push({ ...elem, alpha: 255 }); cups.splice(idx, 1); }
            recalcSides(); checkSetup();
            return;
          }
        }
        
        // Solve mode: new elements appear on BOTH sides
        if (phase === 'solve' && elem.isNew) {
          elem.side = newSide; elem.isNew = false;
          elem.solvePaired = true; // mark as paired
          let mirrorSide = newSide === 'left' ? 'right' : 'left';
          let mirrorX = newSide === 'left' ? elem.x + 440 : elem.x - 440;
          let mirror;
          if (elem.type === 'cup') {
            mirror = { type: 'cup', x: mirrorX, y: elem.y, side: mirrorSide, solvePaired: true, pairId: elem };
            cups.push(mirror);
          } else {
            mirror = { type: 'cube', x: mirrorX, y: elem.y, side: mirrorSide, value: elem.value, solvePaired: true, pairId: elem };
            cubes.push(mirror);
          }
          elem.pairId = mirror;
          recalcSides(); updateSolveStep();
          return;
        }
        
        elem.side = newSide; elem.isNew = false;
        recalcSides(); checkSetup();
      } else {
        // Dragged OFF balance - remove element
        // In solve mode, also remove the paired element
        if (phase === 'solve' && elem.solvePaired && elem.pairId) {
          // Remove the mirror element too
          if (elem.type === 'cup') {
            let idx = cups.indexOf(elem.pairId);
            if (idx > -1) cups.splice(idx, 1);
          } else {
            let idx = cubes.indexOf(elem.pairId);
            if (idx > -1) cubes.splice(idx, 1);
          }
        }
        
        if (elem.type === 'cup') {
          let idx = cups.indexOf(elem);
          if (idx > -1) { fadingElements.push({ ...elem, alpha: 255 }); cups.splice(idx, 1); }
        } else {
          let idx = cubes.indexOf(elem);
          if (idx > -1) cubes.splice(idx, 1);
        }
        recalcSides(); checkSetup();
        
        if (phase === 'solve') updateSolveStep();
      }
    }
    
    function findCupAt(x, y) {
      for (let cup of cups) if (dist(x, y, cup.x, cup.y) < 50) return cup;
      return null;
    }
    
    function mouseMoved() {
      let canSolve = (mode === 'challenge' && leftMatch && rightMatch) || (mode === 'build' && hasContent());
      solveButtonHover = (phase === 'build' && canSolve && mouseX > 380 && mouseX < 520 && mouseY > BUTTON_Y - 24 && mouseY < BUTTON_Y + 24);
      clearButtonHover = (mouseX > 798 && mouseX < 862 && mouseY > SOURCE_Y - 18 && mouseY < SOURCE_Y + 18);
      challengeTabHover = (mouseY > TABS_Y && mouseY < TABS_Y + 32 && mouseX > 25 && mouseX < 125);
      buildTabHover = (mouseY > TABS_Y && mouseY < TABS_Y + 32 && mouseX > 135 && mouseX < 275);
      nextButtonHover = (phase === 'solved' && mode === 'challenge' && mouseX > 685 && mouseX < 815 && mouseY > BUTTON_Y - 22 && mouseY < BUTTON_Y + 22);
      let hasZero = (leftSide.positiveCubes > 0 && leftSide.negativeCubes < 0) || (rightSide.positiveCubes > 0 && rightSide.negativeCubes < 0);
      zeroOutHover = (hasZero && mouseX > 400 && mouseX < 500 && mouseY > BALANCE_BEAM_Y - 44 && mouseY < BALANCE_BEAM_Y - 16);
      
      if (phase === 'solve') {
        let qX = 450 + 75, qY = BUTTON_Y;
        checkHover = dist(mouseX, mouseY, qX, qY) < 20;
      } else checkHover = false;
    }
    
    function keyPressed() {
      if (phase === 'solve' && xInputFocused) {
        if (key === '-') {
          if (xValue === null) xValue = 0;
          xValue = -xValue;
        } else if (key >= '0' && key <= '9') {
          let d = int(key);
          if (xValue === null) xValue = d;
          else if (xValue >= 0) { xValue = xValue * 10 + d; if (xValue > 99) xValue = d; }
          else { xValue = xValue * 10 - d; if (xValue < -99) xValue = -d; }
        } else if (keyCode === BACKSPACE) {
          if (xValue !== null) {
            if (Math.abs(xValue) < 10) xValue = null;
            else xValue = floor(xValue / 10);
          }
        } else if (keyCode === ENTER || keyCode === RETURN) {
          if (xValue !== null) checkAnswer();
        }
      }
    }
    
    function checkAnswer() {
      if (xValue === null) return;
      
      if (mode === 'challenge') {
        if (xValue === targetSolution) {
          solveSteps.push({ left: 'x', right: '' + targetSolution });
          phase = 'solved';
        } else {
          showWrongAnswer = true;
          wrongAnswerTimer = 0;
        }
      } else {
        let l = leftSide.cups * xValue + leftSide.positiveCubes + leftSide.negativeCubes;
        let r = rightSide.cups * xValue + rightSide.positiveCubes + rightSide.negativeCubes;
        if (l === r) {
          solveSteps.push({ left: 'x', right: '' + xValue });
          phase = 'solved';
        } else {
          showWrongAnswer = true;
          wrongAnswerTimer = 0;
        }
      }
    }

    function recalcSides() {
      leftSide.cups = cups.filter(c => c.side === 'left').length;
      leftSide.positiveCubes = cubes.filter(c => c.side === 'left' && c.value > 0).reduce((s, c) => s + c.value, 0);
      leftSide.negativeCubes = cubes.filter(c => c.side === 'left' && c.value < 0).reduce((s, c) => s + c.value, 0);
      rightSide.cups = cups.filter(c => c.side === 'right').length;
      rightSide.positiveCubes = cubes.filter(c => c.side === 'right' && c.value > 0).reduce((s, c) => s + c.value, 0);
      rightSide.negativeCubes = cubes.filter(c => c.side === 'right' && c.value < 0).reduce((s, c) => s + c.value, 0);
    }
    
    function checkSetup() {
      if (mode === 'challenge') {
        let lTotal = leftSide.positiveCubes + leftSide.negativeCubes;
        let rTotal = rightSide.positiveCubes + rightSide.negativeCubes;
        leftMatch = (leftSide.cups === targetA && lTotal === targetB);
        rightMatch = (rightSide.cups === 0 && rTotal === targetC);
      }
    }
    
    function startSolveMode() {
      phase = 'solve'; solveSteps = []; xValue = null; xInputFocused = true;
      showWrongAnswer = false;
    }
    
    function updateSolveStep() {
      let l = buildSideEq(leftSide), r = buildSideEq(rightSide);
      solveSteps.push({ left: l, right: r });
      if (solveSteps.length > 4) solveSteps.shift();
    }

    function clearWithFade() {
      for (let cup of cups) fadingElements.push({ ...cup, alpha: 255 });
      cups = []; cubes = [];
      leftSide = { cups: 0, positiveCubes: 0, negativeCubes: 0 };
      rightSide = { cups: 0, positiveCubes: 0, negativeCubes: 0 };
      leftMatch = false; rightMatch = false;
      xValue = null; solveSteps = [];
      phase = 'build'; xInputFocused = false;
      showWrongAnswer = false;
      if (mode === 'challenge') setTimeout(generateNewProblem, 250);
    }

    function touchStarted() { mousePressed(); return false; }
    function touchMoved() { mouseDragged(); return false; }
    function touchEnded() { mouseReleased(); return false; }
  </script>
</body>
</html>
