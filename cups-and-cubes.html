<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Algebra Studio Balance Lab</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    body { 
      margin: 0; padding: 20px; min-height: 100vh; 
      background: #f5f5f5; display: flex; flex-direction: column; 
      align-items: center; font-family: 'Poppins', sans-serif;
      -webkit-user-select: none; user-select: none; touch-action: none;
    }
    #canvas-container { 
      position: relative; width: 900px; height: 780px;
      background: white; border-radius: 16px;
      box-shadow: 0 2px 20px rgba(0,0,0,0.08); overflow: hidden;
    }
    canvas { display: block; touch-action: none; }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <script>
    let cups = [];
    let cubes = [];
    let selectedElement = null;
    let dragOffsetX = 0, dragOffsetY = 0;
    let mode = 'challenge';
    let targetA = 2, targetB = 3, targetC = 7, targetSolution = 2;
    let leftSide = { cups: 0, positiveCubes: 0, negativeCubes: 0 };
    let rightSide = { cups: 0, positiveCubes: 0, negativeCubes: 0 };
    let phase = 'build';
    let leftMatch = false, rightMatch = false;
    let xValue = null;
    let solveSteps = [];
    let xInputFocused = false;
    let cursorBlink = 0;
    let showWrongAnswer = false;
    let wrongAnswerTimer = 0;
    let zeroOutAnimating = false;
    let zeroOutPairs = [];
    let zeroOutProgress = 0;
    let zeroOutSide = null;
    let zeroOutNetValue = 0;
    let fadingElements = [];
    let solveButtonHover = false, clearButtonHover = false;
    let challengeTabHover = false, buildTabHover = false;
    let nextButtonHover = false, zeroOutHover = false, checkHover = false;
    
    const TABS_Y = 25, EQUATION_Y = 70, STEPS_START_Y = 130;
    const BALANCE_BEAM_Y = 500, EQUATION_DISPLAY_Y = 580;
    const BUTTON_Y = 660, SOURCE_Y = 730;

    function setup() {
      let canvas = createCanvas(900, 780);
      canvas.parent('canvas-container');
      generateNewProblem();
    }

    function generateNewProblem() {
      if (mode === 'challenge') {
        targetSolution = floor(random(1, 6));
        targetA = floor(random(1, 5));
        targetB = floor(random(1, 7));
        targetC = targetA * targetSolution + targetB;
      }
      cups = []; cubes = [];
      leftSide = { cups: 0, positiveCubes: 0, negativeCubes: 0 };
      rightSide = { cups: 0, positiveCubes: 0, negativeCubes: 0 };
      phase = 'build'; leftMatch = false; rightMatch = false;
      xValue = null; solveSteps = []; xInputFocused = false;
      showWrongAnswer = false; wrongAnswerTimer = 0;
      zeroOutAnimating = false; zeroOutPairs = [];
    }

    function draw() {
      background(255);
      updateAnimations();
      drawModeTabs();
      drawEquationArea();
      drawSolveSteps();
      drawBalance();
      drawZeroOutButton();
      drawElementsOnBalance();
      drawEquationDisplay();
      drawButtons();
      drawSourceArea();
      if (selectedElement) drawDraggedElement(selectedElement);
      drawFadingElements();
      drawZeroOutAnimation();
    }

    function drawModeTabs() {
      let tabH = 32;
      let challengeX = 25, challengeW = 100;
      if (mode === 'challenge') {
        fill(100, 60, 160); noStroke();
        rect(challengeX, TABS_Y, challengeW, tabH, 16); fill(255);
      } else {
        fill(challengeTabHover ? 240 : 250);
        stroke(220); strokeWeight(1);
        rect(challengeX, TABS_Y, challengeW, tabH, 16); fill(120);
      }
      noStroke(); textSize(13); textFont('Poppins');
      textAlign(CENTER, CENTER);
      text('Challenge', challengeX + challengeW/2, TABS_Y + tabH/2);
      
      let buildX = 135, buildW = 140;
      if (mode === 'build') {
        fill(100, 60, 160); noStroke();
        rect(buildX, TABS_Y, buildW, tabH, 16); fill(255);
      } else {
        fill(buildTabHover ? 240 : 250);
        stroke(220); strokeWeight(1);
        rect(buildX, TABS_Y, buildW, tabH, 16); fill(120);
      }
      noStroke();
      text('Build an Equation', buildX + buildW/2, TABS_Y + tabH/2);
    }

    function drawEquationArea() {
      textAlign(CENTER, CENTER); textSize(52);
      textFont('Poppins'); fill(40);
      
      if (mode === 'challenge') {
        let eqStr = (targetA === 1 ? 'x' : targetA + 'x') + ' + ' + targetB + ' = ' + targetC;
        text(eqStr, 450, EQUATION_Y);
        
        // Double checkmark when both sides match
        if (leftMatch && rightMatch && phase === 'build') {
          drawCheckmark(700, EQUATION_Y, 1.2, color(34, 197, 94));
          drawCheckmark(750, EQUATION_Y, 1.2, color(34, 197, 94));
        }
        
        if (phase === 'solved') {
          drawCheckmark(680, EQUATION_Y, 1.2, color(34, 197, 94));
          drawCheckmark(730, EQUATION_Y, 1.2, color(34, 197, 94));
          drawCheckmark(780, EQUATION_Y, 1.2, color(34, 197, 94));
        }
      } else {
        let leftEq = buildSideEq(leftSide);
        let rightEq = buildSideEq(rightSide);
        if (leftEq || rightEq) {
          fill(60); text((leftEq || '?') + ' = ' + (rightEq || '?'), 450, EQUATION_Y);
          if (phase === 'solved') drawCheckmark(780, EQUATION_Y, 1.2, color(34, 197, 94));
        } else {
          fill(190); textSize(32);
          text('Drag pieces to build an equation', 450, EQUATION_Y);
        }
      }
    }
    
    function drawCheckmark(x, y, scale, col) {
      push(); translate(x, y);
      stroke(col); strokeWeight(5 * scale); noFill();
      beginShape();
      vertex(-14 * scale, 0);
      vertex(-4 * scale, 10 * scale);
      vertex(14 * scale, -10 * scale);
      endShape(); pop();
    }

    function drawSolveSteps() {
      if (solveSteps.length === 0) return;
      textAlign(CENTER, CENTER); textFont('Poppins'); textSize(28);
      let y = STEPS_START_Y;
      for (let step of solveSteps) {
        fill(50); text(step.left + ' = ' + step.right, 450, y);
        y += 38;
      }
    }

    function drawBalance() {
      fill(30); noStroke();
      triangle(450, BALANCE_BEAM_Y + 8, 415, BALANCE_BEAM_Y + 55, 485, BALANCE_BEAM_Y + 55);
      fill(255); textSize(24); textAlign(CENTER, CENTER);
      
      if (phase === 'solve' && showWrongAnswer) {
        fill(255, 100, 100);
        text("≠", 450, BALANCE_BEAM_Y + 35);
      } else if (phase === 'solved') {
        fill(100, 255, 100);
        text("=", 450, BALANCE_BEAM_Y + 35);
      } else {
        fill(255);
        text("=", 450, BALANCE_BEAM_Y + 35);
      }
      
      stroke(30); strokeWeight(3);
      line(50, BALANCE_BEAM_Y, 415, BALANCE_BEAM_Y);
      line(485, BALANCE_BEAM_Y, 850, BALANCE_BEAM_Y);
      fill(170); noStroke(); textSize(13); textFont('Poppins');
      text('LEFT', 230, BALANCE_BEAM_Y + 18);
      text('RIGHT', 670, BALANCE_BEAM_Y + 18);
    }
    
    function drawZeroOutButton() {
      if (zeroOutAnimating) return;
      let hasZero = (leftSide.positiveCubes > 0 && leftSide.negativeCubes < 0) ||
                    (rightSide.positiveCubes > 0 && rightSide.negativeCubes < 0);
      if (hasZero) {
        let btnX = 450, btnY = BALANCE_BEAM_Y - 30;
        if (zeroOutHover) { fill(100, 60, 160); noStroke(); }
        else { fill(245); stroke(200); strokeWeight(1); }
        rect(btnX - 50, btnY - 14, 100, 28, 14);
        fill(zeroOutHover ? 255 : 100); noStroke();
        textSize(12); textFont('Poppins'); textAlign(CENTER, CENTER);
        text('ZERO OUT', btnX, btnY);
      }
    }
    
    function drawEquationDisplay() {
      let leftEq = buildSideEq(leftSide);
      let rightEq = buildSideEq(rightSide);
      if (leftEq === '' && rightEq === '') return;
      
      textSize(32); textFont('Poppins'); textAlign(CENTER, CENTER);
      
      // Left side
      fill(60); text(leftEq || '0', 230, EQUATION_DISPLAY_Y);
      if (mode === 'challenge' && leftMatch && phase === 'build') {
        drawCheckmark(350, EQUATION_DISPLAY_Y, 0.8, color(34, 197, 94));
      }
      
      // Equals sign
      if (phase === 'solve' && showWrongAnswer) {
        fill(200, 80, 80); text('≠', 450, EQUATION_DISPLAY_Y);
      } else if (phase === 'solved') {
        fill(34, 197, 94); text('=', 450, EQUATION_DISPLAY_Y);
      } else {
        fill(140); text('=', 450, EQUATION_DISPLAY_Y);
      }
      
      // Right side
      fill(60); text(rightEq || '0', 670, EQUATION_DISPLAY_Y);
      if (mode === 'challenge' && rightMatch && phase === 'build') {
        drawCheckmark(550, EQUATION_DISPLAY_Y, 0.8, color(34, 197, 94));
      }
    }
    
    function buildSideEq(side) {
      let parts = [];
      if (side.cups > 0) parts.push(side.cups === 1 ? 'x' : side.cups + 'x');
      if (side.positiveCubes > 0) {
        parts.push((parts.length > 0 ? '+ ' : '') + side.positiveCubes);
      }
      if (side.negativeCubes < 0) {
        if (parts.length > 0) parts.push('+ (' + side.negativeCubes + ')');
        else parts.push('' + side.negativeCubes);
      }
      return parts.join(' ');
    }

    function drawElementsOnBalance() {
      for (let cup of cups) {
        if (cup !== selectedElement) {
          drawCup(cup.x, cup.y, 75, 65);
          if ((phase === 'solve' || phase === 'solved') && xValue !== null && xValue !== 0) {
            drawCubesInCup(cup);
          }
        }
      }
      for (let cube of cubes) {
        if (cube !== selectedElement && !cube.zeroingOut) {
          drawCubeUnit(cube.x, cube.y, cube.value);
        }
      }
    }
    
    function drawCubesInCup(cup) {
      let size = 14, cols = 3;
      let absVal = Math.abs(xValue);
      let col = xValue > 0 ? 'green' : 'black';
      let startX = cup.x - (cols * size) / 2 + size/2;
      let startY = cup.y + 22;
      for (let i = 0; i < absVal && i < 12; i++) {
        let row = floor(i / cols), c = i % cols;
        drawSingleCube(startX + c * (size + 2), startY - row * (size + 2), size, col);
      }
    }
    
    function drawCup(x, y, w, h) {
      fill(235, 245, 255, 200); stroke(170, 195, 220); strokeWeight(2);
      beginShape();
      vertex(x - w/2, y - h/2); vertex(x + w/2, y - h/2);
      vertex(x + w/2 * 0.82, y + h/2); vertex(x - w/2 * 0.82, y + h/2);
      endShape(CLOSE);
      stroke(190, 210, 230); strokeWeight(1);
      line(x - w/2, y - h/2, x + w/2, y - h/2);
    }
    
    function drawCubeUnit(x, y, value) {
      let size = 22, absVal = Math.abs(value);
      let col = value > 0 ? 'green' : 'black';
      if (absVal === 1) drawSingleCube(x, y, size, col);
      else if (absVal === 3) {
        drawSingleCube(x - size - 2, y, size, col);
        drawSingleCube(x, y, size, col);
        drawSingleCube(x + size + 2, y, size, col);
      } else if (absVal === 9) {
        let s = size - 2;
        for (let r = 0; r < 3; r++) for (let c = 0; c < 3; c++)
          drawSingleCube(x + (c - 1) * (s + 1), y + (r - 1) * (s + 1), s, col);
      }
    }
    
    function drawSingleCube(x, y, size, col) {
      let s = size, off = s * 0.22;
      if (col === 'green') {
        fill(0, 105, 0); noStroke();
        quad(x+s/2, y-s/2+off, x+s/2+off, y-s/2, x+s/2+off, y+s/2, x+s/2, y+s/2+off);
        fill(0, 175, 0);
        quad(x-s/2, y-s/2+off, x-s/2+off, y-s/2, x+s/2+off, y-s/2, x+s/2, y-s/2+off);
        fill(0, 140, 0); stroke(0, 95, 0); strokeWeight(1);
        rect(x - s/2, y - s/2 + off, s, s);
      } else {
        fill(50); noStroke();
        quad(x+s/2, y-s/2+off, x+s/2+off, y-s/2, x+s/2+off, y+s/2, x+s/2, y+s/2+off);
        fill(100);
        quad(x-s/2, y-s/2+off, x-s/2+off, y-s/2, x+s/2+off, y-s/2, x+s/2, y-s/2+off);
        fill(70); stroke(40); strokeWeight(1);
        rect(x - s/2, y - s/2 + off, s, s);
      }
    }
    
    function drawDraggedElement(elem) {
      if (elem.type === 'cup') drawCup(elem.x, elem.y, 80, 70);
      else drawCubeUnit(elem.x, elem.y, elem.value);
    }

    function drawButtons() {
      // Solve button when both sides match
      if (phase === 'build' && mode === 'challenge' && leftMatch && rightMatch) {
        let btnX = 450, btnY = BUTTON_Y;
        fill(solveButtonHover ? color(85, 50, 140) : color(100, 60, 160));
        noStroke(); rect(btnX - 70, btnY - 24, 140, 48, 12);
        fill(255); textSize(18); textFont('Poppins'); textAlign(CENTER, CENTER);
        text('Solve', btnX, btnY);
      }
      
      // Build mode test button
      if (phase === 'build' && mode === 'build' && hasContent()) {
        let btnX = 450, btnY = BUTTON_Y;
        fill(solveButtonHover ? color(85, 50, 140) : color(100, 60, 160));
        noStroke(); rect(btnX - 70, btnY - 24, 140, 48, 12);
        fill(255); textSize(18); textFont('Poppins'); textAlign(CENTER, CENTER);
        text('Test a Value', btnX, btnY);
      }
      
      if (phase === 'solve' || phase === 'solved') drawXInput();
      
      if (phase === 'solved' && mode === 'challenge') {
        let btnX = 750, btnY = BUTTON_Y;
        fill(nextButtonHover ? color(85, 50, 140) : color(100, 60, 160));
        noStroke(); rect(btnX - 65, btnY - 22, 130, 44, 10);
        fill(255); textSize(15); textFont('Poppins'); textAlign(CENTER, CENTER);
        text('Next Question', btnX, btnY);
      }
    }
    
    function hasContent() {
      return leftSide.cups > 0 || leftSide.positiveCubes > 0 || leftSide.negativeCubes < 0 ||
             rightSide.cups > 0 || rightSide.positiveCubes > 0 || rightSide.negativeCubes < 0;
    }
    
    function drawXInput() {
      let inputX = 450, inputY = BUTTON_Y;
      fill(60); textSize(28); textFont('Poppins');
      textAlign(RIGHT, CENTER); text('x =', inputX - 50, inputY);
      
      fill(255);
      if (phase === 'solved') { stroke(34, 197, 94); strokeWeight(3); }
      else if (xInputFocused) { stroke(100, 60, 160); strokeWeight(2); }
      else { stroke(190); strokeWeight(1); }
      rect(inputX - 35, inputY - 24, 90, 48, 8);
      
      noStroke(); textAlign(CENTER, CENTER);
      if (xValue !== null) { fill(40); text(xValue, inputX + 10, inputY); }
      else if (xInputFocused && phase === 'solve') {
        if (floor(cursorBlink / 30) % 2 === 0) {
          stroke(100, 60, 160); strokeWeight(2);
          line(inputX + 10, inputY - 12, inputX + 10, inputY + 12);
        }
      }
      
      if (phase === 'solve' && !xInputFocused && xValue === null) {
        fill(180); textSize(11); text('click to type', inputX + 10, inputY);
      }
      
      // Question mark button
      if (phase === 'solve') {
        let qX = inputX + 75, qY = inputY;
        fill(checkHover ? color(100, 60, 160) : 220);
        noStroke(); ellipse(qX, qY, 36, 36);
        fill(checkHover ? 255 : 80);
        textSize(22); textAlign(CENTER, CENTER);
        text('?', qX, qY);
      }
    }

    function drawSourceArea() {
      stroke(230); strokeWeight(1);
      line(60, SOURCE_Y - 45, 840, SOURCE_Y - 45);
      drawCup(80, SOURCE_Y, 60, 52);
      fill(150); noStroke(); textSize(11); textFont('Poppins'); textAlign(CENTER);
      text('x', 80, SOURCE_Y + 40);
      drawSingleCube(170, SOURCE_Y, 22, 'green'); fill(34, 139, 34); text('+1', 170, SOURCE_Y + 40);
      drawCubeUnit(270, SOURCE_Y, 3); fill(34, 139, 34); text('+3', 270, SOURCE_Y + 40);
      drawCubeUnit(400, SOURCE_Y, 9); fill(34, 139, 34); text('+9', 400, SOURCE_Y + 40);
      drawSingleCube(520, SOURCE_Y, 22, 'black'); fill(60); text('-1', 520, SOURCE_Y + 40);
      drawCubeUnit(620, SOURCE_Y, -3); fill(60); text('-3', 620, SOURCE_Y + 40);
      drawCubeUnit(750, SOURCE_Y, -9); fill(60); text('-9', 750, SOURCE_Y + 40);
      
      let clearX = 855, clearY = SOURCE_Y;
      fill(clearButtonHover ? 235 : 248); stroke(200); strokeWeight(1);
      rect(clearX - 32, clearY - 18, 64, 36, 8);
      fill(120); noStroke(); textSize(14); textAlign(CENTER, CENTER);
      text('Clear', clearX, clearY);
    }

    function drawZeroOutAnimation() {
      if (!zeroOutAnimating) return;
      
      let p = zeroOutProgress;
      
      for (let pair of zeroOutPairs) {
        if (p < 0.5) {
          // Move toward each other
          let t = p / 0.5;
          let x1 = lerp(pair.gx, pair.mx - 14, t);
          let x2 = lerp(pair.bx, pair.mx + 14, t);
          let y1 = lerp(pair.gy, pair.my, t);
          let y2 = lerp(pair.by, pair.my, t);
          drawSingleCube(x1, y1, 22, 'green');
          drawSingleCube(x2, y2, 22, 'black');
        } else if (p < 0.8) {
          // Kiss and drop
          let t = (p - 0.5) / 0.3;
          let dropY = lerp(pair.my, SOURCE_Y - 50, t);
          let alpha = 255 * (1 - t * 0.5);
          drawSingleCube(pair.mx - 14, dropY, 22, 'green');
          drawSingleCube(pair.mx + 14, dropY, 22, 'black');
        }
        // After 0.8, don't draw - they've faded
      }
    }
    
    function startZeroOut() {
      zeroOutAnimating = true;
      zeroOutProgress = 0;
      zeroOutPairs = [];
      
      // Process each side by VALUE, not by object
      for (let side of ['left', 'right']) {
        let sideCubes = cubes.filter(c => c.side === side);
        let posTotal = sideCubes.filter(c => c.value > 0).reduce((s, c) => s + c.value, 0);
        let negTotal = Math.abs(sideCubes.filter(c => c.value < 0).reduce((s, c) => s + c.value, 0));
        
        if (posTotal === 0 || negTotal === 0) continue;
        
        let pairsToCancel = min(posTotal, negTotal);
        
        // Get average positions for animation
        let posCubes = sideCubes.filter(c => c.value > 0);
        let negCubes = sideCubes.filter(c => c.value < 0);
        
        let posAvgX = posCubes.reduce((s, c) => s + c.x, 0) / posCubes.length;
        let posAvgY = posCubes.reduce((s, c) => s + c.y, 0) / posCubes.length;
        let negAvgX = negCubes.reduce((s, c) => s + c.x, 0) / negCubes.length;
        let negAvgY = negCubes.reduce((s, c) => s + c.y, 0) / negCubes.length;
        
        let meetX = (posAvgX + negAvgX) / 2;
        let meetY = (posAvgY + negAvgY) / 2;
        
        // Create visual pairs for animation (one pair per unit cancelled)
        for (let i = 0; i < pairsToCancel; i++) {
          zeroOutPairs.push({
            gx: posAvgX + random(-15, 15),
            gy: posAvgY + random(-15, 15),
            bx: negAvgX + random(-15, 15),
            by: negAvgY + random(-15, 15),
            mx: meetX,
            my: meetY,
            side: side
          });
        }
        
        // Mark ALL cubes on this side for removal
        for (let cube of sideCubes) {
          cube.zeroingOut = true;
          cube.originalValue = cube.value;
          cube.side = side;
        }
        
        // Calculate net value after zeroing
        let netValue = posTotal - negTotal;
        
        // Store info for creating replacement cubes
        if (!zeroOutSide) zeroOutSide = {};
        zeroOutSide[side] = {
          netValue: netValue,
          avgX: side === 'left' ? 300 : 740,
          avgY: BALANCE_BEAM_Y - 80
        };
      }
    }
    
    function finishZeroOut() {
      // Remove all cubes marked for zeroing
      let sidesToProcess = {};
      for (let cube of cubes) {
        if (cube.zeroingOut) {
          sidesToProcess[cube.side] = true;
        }
      }
      cubes = cubes.filter(c => !c.zeroingOut);
      
      // Add back cubes for net values
      if (zeroOutSide) {
        for (let side in zeroOutSide) {
          let info = zeroOutSide[side];
          let netValue = info.netValue;
          
          if (netValue !== 0) {
            // Create new cube(s) for the net value
            let isPositive = netValue > 0;
            let absVal = Math.abs(netValue);
            
            // Try to use fewest cubes (9s, then 3s, then 1s)
            let y = info.avgY;
            while (absVal >= 9) {
              cubes.push({
                type: 'cube',
                x: info.avgX + random(-20, 20),
                y: y,
                side: side,
                value: isPositive ? 9 : -9
              });
              absVal -= 9;
              y -= 50;
            }
            while (absVal >= 3) {
              cubes.push({
                type: 'cube',
                x: info.avgX + random(-20, 20),
                y: y,
                side: side,
                value: isPositive ? 3 : -3
              });
              absVal -= 3;
              y -= 35;
            }
            while (absVal >= 1) {
              cubes.push({
                type: 'cube',
                x: info.avgX + random(-20, 20),
                y: y,
                side: side,
                value: isPositive ? 1 : -1
              });
              absVal -= 1;
              y -= 30;
            }
          }
        }
      }
      
      zeroOutAnimating = false;
      zeroOutPairs = [];
      zeroOutSide = null;
      recalcSides();
      
      if (phase === 'solve') updateSolveStep();
    }

    function drawFadingElements() {
      for (let elem of fadingElements) {
        if (elem.type === 'cup') {
          fill(235, 245, 255, elem.alpha * 0.8);
          stroke(170, 195, 220, elem.alpha); strokeWeight(2);
          beginShape();
          vertex(elem.x - 37, elem.y - 32); vertex(elem.x + 37, elem.y - 32);
          vertex(elem.x + 30, elem.y + 32); vertex(elem.x - 30, elem.y + 32);
          endShape(CLOSE);
        }
      }
    }
    
    function updateAnimations() {
      cursorBlink++;
      if (showWrongAnswer) {
        wrongAnswerTimer++;
        if (wrongAnswerTimer > 60) {
          showWrongAnswer = false;
          wrongAnswerTimer = 0;
        }
      }
      for (let i = fadingElements.length - 1; i >= 0; i--) {
        fadingElements[i].alpha -= 15;
        if (fadingElements[i].alpha <= 0) fadingElements.splice(i, 1);
      }
      if (zeroOutAnimating) {
        zeroOutProgress += 0.02;
        if (zeroOutProgress >= 1) finishZeroOut();
      }
    }

    // Get exclusion radius for a cube based on its value
    function getCubeRadius(value) {
      let absVal = Math.abs(value);
      if (absVal === 9) return 45;
      if (absVal === 3) return 42;
      return 22;
    }

    // Check if a cup can be placed at position (avoiding cubes)
    function canPlaceCupAt(x, y, ignoreCup) {
      const CUP_RADIUS = 45;
      for (let cube of cubes) {
        let cubeRadius = getCubeRadius(cube.value);
        let minDist = CUP_RADIUS + cubeRadius;
        if (dist(x, y, cube.x, cube.y) < minDist) {
          return false;
        }
      }
      return true;
    }

    function mousePressed() {
      let mx = mouseX, my = mouseY;
      
      if (my > TABS_Y && my < TABS_Y + 32) {
        if (mx > 25 && mx < 125 && mode !== 'challenge') { mode = 'challenge'; generateNewProblem(); return; }
        if (mx > 135 && mx < 275 && mode !== 'build') { mode = 'build'; generateNewProblem(); return; }
      }
      
      if (mx > 823 && mx < 887 && my > SOURCE_Y - 18 && my < SOURCE_Y + 18) { clearWithFade(); return; }
      
      if (phase === 'solved' && mode === 'challenge' && mx > 685 && mx < 815 && my > BUTTON_Y - 22 && my < BUTTON_Y + 22) {
        generateNewProblem(); return;
      }
      
      // Question mark to check answer
      if (phase === 'solve' && xValue !== null) {
        let qX = 450 + 75, qY = BUTTON_Y;
        if (dist(mx, my, qX, qY) < 20) {
          checkAnswer(); return;
        }
      }
      
      if ((phase === 'solve' || phase === 'solved') && mx > 415 && mx < 505 && my > BUTTON_Y - 24 && my < BUTTON_Y + 24) {
        xInputFocused = true; return;
      } else xInputFocused = false;
      
      let hasZero = (leftSide.positiveCubes > 0 && leftSide.negativeCubes < 0) ||
                    (rightSide.positiveCubes > 0 && rightSide.negativeCubes < 0);
      if (hasZero && !zeroOutAnimating && mx > 400 && mx < 500 && my > BALANCE_BEAM_Y - 44 && my < BALANCE_BEAM_Y - 16) {
        startZeroOut(); return;
      }
      
      if (phase === 'build') {
        let canSolve = (mode === 'challenge' && leftMatch && rightMatch) || (mode === 'build' && hasContent());
        if (canSolve && mx > 380 && mx < 520 && my > BUTTON_Y - 24 && my < BUTTON_Y + 24) {
          startSolveMode(); return;
        }
      }
      
      for (let cup of cups) {
        if (dist(mx, my, cup.x, cup.y) < 42) {
          selectedElement = cup;
          dragOffsetX = cup.x - mx; dragOffsetY = cup.y - my;
          return;
        }
      }
      for (let cube of cubes) {
        let hitR = getCubeRadius(cube.value);
        if (dist(mx, my, cube.x, cube.y) < hitR) {
          selectedElement = cube;
          dragOffsetX = cube.x - mx; dragOffsetY = cube.y - my;
          return;
        }
      }
      
      if (dist(mx, my, 80, SOURCE_Y) < 38) {
        selectedElement = { type: 'cup', x: mx, y: my, side: null, isNew: true };
        cups.push(selectedElement); return;
      }
      if (dist(mx, my, 170, SOURCE_Y) < 22) {
        selectedElement = { type: 'cube', x: mx, y: my, side: null, value: 1, isNew: true };
        cubes.push(selectedElement); return;
      }
      if (dist(mx, my, 270, SOURCE_Y) < 42) {
        selectedElement = { type: 'cube', x: mx, y: my, side: null, value: 3, isNew: true };
        cubes.push(selectedElement); return;
      }
      if (dist(mx, my, 400, SOURCE_Y) < 45) {
        selectedElement = { type: 'cube', x: mx, y: my, side: null, value: 9, isNew: true };
        cubes.push(selectedElement); return;
      }
      if (dist(mx, my, 520, SOURCE_Y) < 22) {
        selectedElement = { type: 'cube', x: mx, y: my, side: null, value: -1, isNew: true };
        cubes.push(selectedElement); return;
      }
      if (dist(mx, my, 620, SOURCE_Y) < 42) {
        selectedElement = { type: 'cube', x: mx, y: my, side: null, value: -3, isNew: true };
        cubes.push(selectedElement); return;
      }
      if (dist(mx, my, 750, SOURCE_Y) < 45) {
        selectedElement = { type: 'cube', x: mx, y: my, side: null, value: -9, isNew: true };
        cubes.push(selectedElement); return;
      }
    }
    
    function mouseDragged() {
      if (selectedElement) {
        selectedElement.x = mouseX + dragOffsetX;
        selectedElement.y = mouseY + dragOffsetY;
      }
    }
    
    function mouseReleased() {
      if (!selectedElement) return;
      let elem = selectedElement;
      selectedElement = null;
      
      let onBalance = elem.y < BALANCE_BEAM_Y - 20 && elem.y > 150;
      let onLeft = elem.x > 50 && elem.x < 415;
      let onRight = elem.x > 485 && elem.x < 850;
      
      // Check drop in cup (for x value)
      if (elem.type === 'cube') {
        let cup = findCupAt(elem.x, elem.y);
        if (cup) {
          if (xValue === null) xValue = elem.value;
          else xValue += elem.value;
          let idx = cubes.indexOf(elem);
          if (idx > -1) cubes.splice(idx, 1);
          return;
        }
      }
      
      if (onBalance && (onLeft || onRight)) {
        let newSide = onLeft ? 'left' : 'right';
        
        // Cup placement - check exclusion zones around cubes
        if (elem.type === 'cup') {
          if (!canPlaceCupAt(elem.x, elem.y, elem)) {
            // Can't place here - remove
            let idx = cups.indexOf(elem);
            if (idx > -1) { fadingElements.push({ ...elem, alpha: 255 }); cups.splice(idx, 1); }
            recalcSides(); checkSetup();
            return;
          }
        }
        
        // Solve mode: new elements appear on BOTH sides
        if (phase === 'solve' && elem.isNew) {
          elem.side = newSide; elem.isNew = false;
          let mirrorSide = newSide === 'left' ? 'right' : 'left';
          let mirrorX = newSide === 'left' ? elem.x + 440 : elem.x - 440;
          if (elem.type === 'cup') {
            cups.push({ type: 'cup', x: mirrorX, y: elem.y, side: mirrorSide });
          } else {
            cubes.push({ type: 'cube', x: mirrorX, y: elem.y, side: mirrorSide, value: elem.value });
          }
          recalcSides(); updateSolveStep();
          return;
        }
        
        elem.side = newSide; elem.isNew = false;
        recalcSides(); checkSetup();
      } else {
        // Remove element
        if (elem.type === 'cup') {
          let idx = cups.indexOf(elem);
          if (idx > -1) { fadingElements.push({ ...elem, alpha: 255 }); cups.splice(idx, 1); }
        } else {
          let idx = cubes.indexOf(elem);
          if (idx > -1) cubes.splice(idx, 1);
        }
        recalcSides(); checkSetup();
      }
    }
    
    function findCupAt(x, y) {
      for (let cup of cups) if (dist(x, y, cup.x, cup.y) < 50) return cup;
      return null;
    }
    
    function mouseMoved() {
      let canSolve = (mode === 'challenge' && leftMatch && rightMatch) || (mode === 'build' && hasContent());
      solveButtonHover = (phase === 'build' && canSolve && mouseX > 380 && mouseX < 520 && mouseY > BUTTON_Y - 24 && mouseY < BUTTON_Y + 24);
      clearButtonHover = (mouseX > 823 && mouseX < 887 && mouseY > SOURCE_Y - 18 && mouseY < SOURCE_Y + 18);
      challengeTabHover = (mouseY > TABS_Y && mouseY < TABS_Y + 32 && mouseX > 25 && mouseX < 125);
      buildTabHover = (mouseY > TABS_Y && mouseY < TABS_Y + 32 && mouseX > 135 && mouseX < 275);
      nextButtonHover = (phase === 'solved' && mode === 'challenge' && mouseX > 685 && mouseX < 815 && mouseY > BUTTON_Y - 22 && mouseY < BUTTON_Y + 22);
      let hasZero = (leftSide.positiveCubes > 0 && leftSide.negativeCubes < 0) || (rightSide.positiveCubes > 0 && rightSide.negativeCubes < 0);
      zeroOutHover = (hasZero && mouseX > 400 && mouseX < 500 && mouseY > BALANCE_BEAM_Y - 44 && mouseY < BALANCE_BEAM_Y - 16);
      
      if (phase === 'solve') {
        let qX = 450 + 75, qY = BUTTON_Y;
        checkHover = dist(mouseX, mouseY, qX, qY) < 20;
      } else checkHover = false;
    }
    
    function keyPressed() {
      if (phase === 'solve' && xInputFocused) {
        if (key === '-') {
          if (xValue === null) xValue = 0;
          xValue = -xValue;
        } else if (key >= '0' && key <= '9') {
          let d = int(key);
          if (xValue === null) xValue = d;
          else if (xValue >= 0) { xValue = xValue * 10 + d; if (xValue > 99) xValue = d; }
          else { xValue = xValue * 10 - d; if (xValue < -99) xValue = -d; }
        } else if (keyCode === BACKSPACE) {
          if (xValue !== null) {
            if (Math.abs(xValue) < 10) xValue = null;
            else xValue = floor(xValue / 10);
          }
        } else if (keyCode === ENTER || keyCode === RETURN) {
          if (xValue !== null) checkAnswer();
        }
      }
    }
    
    function checkAnswer() {
      if (xValue === null) return;
      
      if (mode === 'challenge') {
        if (xValue === targetSolution) {
          solveSteps.push({ left: 'x', right: '' + targetSolution });
          phase = 'solved';
        } else {
          showWrongAnswer = true;
          wrongAnswerTimer = 0;
        }
      } else {
        let l = leftSide.cups * xValue + leftSide.positiveCubes + leftSide.negativeCubes;
        let r = rightSide.cups * xValue + rightSide.positiveCubes + rightSide.negativeCubes;
        if (l === r) {
          solveSteps.push({ left: 'x', right: '' + xValue });
          phase = 'solved';
        } else {
          showWrongAnswer = true;
          wrongAnswerTimer = 0;
        }
      }
    }

    function recalcSides() {
      leftSide.cups = cups.filter(c => c.side === 'left').length;
      leftSide.positiveCubes = cubes.filter(c => c.side === 'left' && c.value > 0).reduce((s, c) => s + c.value, 0);
      leftSide.negativeCubes = cubes.filter(c => c.side === 'left' && c.value < 0).reduce((s, c) => s + c.value, 0);
      rightSide.cups = cups.filter(c => c.side === 'right').length;
      rightSide.positiveCubes = cubes.filter(c => c.side === 'right' && c.value > 0).reduce((s, c) => s + c.value, 0);
      rightSide.negativeCubes = cubes.filter(c => c.side === 'right' && c.value < 0).reduce((s, c) => s + c.value, 0);
    }
    
    function checkSetup() {
      if (mode === 'challenge') {
        let lTotal = leftSide.positiveCubes + leftSide.negativeCubes;
        let rTotal = rightSide.positiveCubes + rightSide.negativeCubes;
        leftMatch = (leftSide.cups === targetA && lTotal === targetB);
        rightMatch = (rightSide.cups === 0 && rTotal === targetC);
      }
    }
    
    function startSolveMode() {
      phase = 'solve'; solveSteps = []; xValue = null; xInputFocused = true;
      showWrongAnswer = false;
    }
    
    function updateSolveStep() {
      let l = buildSideEq(leftSide), r = buildSideEq(rightSide);
      solveSteps.push({ left: l, right: r });
      if (solveSteps.length > 4) solveSteps.shift();
    }

    function clearWithFade() {
      for (let cup of cups) fadingElements.push({ ...cup, alpha: 255 });
      cups = []; cubes = [];
      leftSide = { cups: 0, positiveCubes: 0, negativeCubes: 0 };
      rightSide = { cups: 0, positiveCubes: 0, negativeCubes: 0 };
      leftMatch = false; rightMatch = false;
      xValue = null; solveSteps = [];
      phase = 'build'; xInputFocused = false;
      showWrongAnswer = false;
      if (mode === 'challenge') setTimeout(generateNewProblem, 250);
    }

    function touchStarted() { mousePressed(); return false; }
    function touchMoved() { mouseDragged(); return false; }
    function touchEnded() { mouseReleased(); return false; }
  </script>
</body>
</html>
