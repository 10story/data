<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Algebra Studio Balance Lab</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    body { 
      margin: 0; padding: 20px; min-height: 100vh; 
      background: #f5f5f5; display: flex; flex-direction: column; 
      align-items: center; font-family: 'Poppins', sans-serif;
      -webkit-user-select: none; user-select: none; touch-action: none;
    }
    #canvas-container { 
      position: relative; width: 900px; height: 685px;
      background: white; border-radius: 16px;
      box-shadow: 0 2px 20px rgba(0,0,0,0.08); overflow: hidden;
    }
    canvas { display: block; touch-action: none; }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <script>
    let cups = [];
    let cubes = [];
    let selectedElement = null;
    let dragOffsetX = 0, dragOffsetY = 0;
    let mode = 'challenge';
    let questionType = '2-step';
    let questionTypes = ['1-step', '1-step with ( - )', '2-step', '2-step with ( - )', 'Distributive'];
    let dropdownOpen = false;
    let dropdownHoverIndex = -1;
    let targetA = 2, targetB = 3, targetC = 7, targetSolution = 2;
    let distributiveA = 2, distributiveB = 3; // for distributive: a(x + b) = c
    let leftSide = { cups: 0, positiveCubes: 0, negativeCubes: 0 };
    let rightSide = { cups: 0, positiveCubes: 0, negativeCubes: 0 };
    let phase = 'build';
    let leftMatch = false, rightMatch = false;
    let xValue = null;
    let solveSteps = [];
    let xInputFocused = false;
    let cursorBlink = 0;
    let showWrongAnswer = false;
    let wrongAnswerTimer = 0;
    let zeroOutAnimating = false;
    let zeroOutPairs = [];
    let zeroOutProgress = 0;
    let fadingElements = [];
    let solveButtonHover = false, newQuestionHover = false;
    let challengeTabHover = false, buildTabHover = false;
    let nextButtonHover = false, zeroOutHover = false, checkHover = false;
    let clearButtonHover = false;
    let dropdownButtonHover = false;
    
    let equationBalanced = true;
    
    let balanceTilt = 0;
    let balanceTiltTarget = 0;
    let balanceTiltMax = 8;
    
    const TABS_Y = 25, EQUATION_Y = 70, STEPS_START_Y = 130;
    const BALANCE_BEAM_Y = 385, EQUATION_DISPLAY_Y = 465;
    const BUTTON_Y = 535, SOURCE_Y = 635;
    const DROPDOWN_Y = 62;

    function setup() {
      let canvas = createCanvas(900, 685);
      canvas.parent('canvas-container');
      generateNewProblem();
    }

    function generateNewProblem() {
      if (mode === 'challenge') {
        generateProblemForType(questionType);
      }
      clearBalance();
    }
    
    function generateProblemForType(type) {
      if (type === '1-step') {
        // ax = c or x + b = c
        if (random() < 0.5) {
          targetA = floor(random(2, 5));
          targetB = 0;
          targetSolution = floor(random(1, 6));
          targetC = targetA * targetSolution;
        } else {
          targetA = 1;
          targetB = floor(random(1, 9));
          targetSolution = floor(random(1, 6));
          targetC = targetSolution + targetB;
        }
      } else if (type === '1-step with ( - )') {
        if (random() < 0.5) {
          targetA = floor(random(2, 5));
          targetB = 0;
          targetSolution = floor(random(-5, 6));
          if (targetSolution === 0) targetSolution = 1;
          targetC = targetA * targetSolution;
        } else {
          targetA = 1;
          targetB = floor(random(-8, 9));
          if (targetB === 0) targetB = 1;
          targetSolution = floor(random(-5, 6));
          if (targetSolution === 0) targetSolution = 1;
          targetC = targetSolution + targetB;
        }
      } else if (type === '2-step') {
        targetSolution = floor(random(1, 6));
        targetA = floor(random(1, 5));
        targetB = floor(random(1, 7));
        targetC = targetA * targetSolution + targetB;
      } else if (type === '2-step with ( - )') {
        targetSolution = floor(random(-5, 6));
        if (targetSolution === 0) targetSolution = 1;
        targetA = floor(random(1, 5));
        targetB = floor(random(-6, 7));
        if (targetB === 0) targetB = 1;
        targetC = targetA * targetSolution + targetB;
      } else if (type === 'Distributive') {
        targetSolution = floor(random(1, 5));
        distributiveA = floor(random(2, 5));
        distributiveB = floor(random(1, 5));
        targetA = distributiveA;
        targetB = distributiveA * distributiveB;
        targetC = distributiveA * (targetSolution + distributiveB);
      }
    }
    
    function clearBalance() {
      cups = []; cubes = [];
      leftSide = { cups: 0, positiveCubes: 0, negativeCubes: 0 };
      rightSide = { cups: 0, positiveCubes: 0, negativeCubes: 0 };
      phase = 'build'; leftMatch = false; rightMatch = false;
      xValue = null; solveSteps = []; xInputFocused = false;
      showWrongAnswer = false; wrongAnswerTimer = 0;
      zeroOutAnimating = false; zeroOutPairs = [];
      equationBalanced = true;
      balanceTilt = 0; balanceTiltTarget = 0;
    }

    function draw() {
      background(255);
      updateAnimations();
      drawModeTabs();
      drawEquationArea();
      drawSolveSteps();
      drawBalance();
      drawZeroOutButton();
      drawElementsOnBalance();
      drawEquationDisplay();
      drawButtons();
      drawSourceArea();
      if (selectedElement) drawDraggedElement(selectedElement);
      drawFadingElements();
      drawZeroOutAnimation();
      drawDropdown();
    }

    function drawModeTabs() {
      let tabH = 32;
      let challengeX = 25, challengeW = 100;
      if (mode === 'challenge') {
        fill(100, 60, 160); noStroke();
        rect(challengeX, TABS_Y, challengeW, tabH, 16); fill(255);
      } else {
        fill(challengeTabHover ? 240 : 250);
        stroke(220); strokeWeight(1);
        rect(challengeX, TABS_Y, challengeW, tabH, 16); fill(120);
      }
      noStroke(); textSize(13); textFont('Poppins');
      textAlign(CENTER, CENTER);
      text('Challenge', challengeX + challengeW/2, TABS_Y + tabH/2);
      
      // Dropdown button under Challenge (only in challenge mode)
      if (mode === 'challenge') {
        let dbX = 25, dbW = 130, dbH = 24;
        fill(dropdownButtonHover || dropdownOpen ? 235 : 245);
        stroke(200); strokeWeight(1);
        rect(dbX, DROPDOWN_Y, dbW, dbH, 12);
        fill(100); noStroke();
        textSize(11);
        text(questionType + ' ▼', dbX + dbW/2, DROPDOWN_Y + dbH/2);
      }
      
      let buildX = 165, buildW = 140;
      if (mode === 'build') {
        fill(100, 60, 160); noStroke();
        rect(buildX, TABS_Y, buildW, tabH, 16); fill(255);
      } else {
        fill(buildTabHover ? 240 : 250);
        stroke(220); strokeWeight(1);
        rect(buildX, TABS_Y, buildW, tabH, 16); fill(120);
      }
      noStroke(); textSize(13);
      text('Build an Equation', buildX + buildW/2, TABS_Y + tabH/2);
      
      // New Question button
      let nqX = 630, nqW = 120;
      fill(newQuestionHover ? 240 : 250);
      stroke(220); strokeWeight(1);
      rect(nqX, TABS_Y, nqW, tabH, 16);
      fill(120); noStroke();
      text('New Question', nqX + nqW/2, TABS_Y + tabH/2);
    }
    
    function drawDropdown() {
      if (!dropdownOpen || mode !== 'challenge') return;
      
      let dbX = 25, dbW = 130, itemH = 28;
      let startY = DROPDOWN_Y + 28;
      
      // Background
      fill(255); stroke(200); strokeWeight(1);
      rect(dbX, startY, dbW, questionTypes.length * itemH, 8);
      
      // Items
      noStroke(); textSize(11); textAlign(CENTER, CENTER);
      for (let i = 0; i < questionTypes.length; i++) {
        let itemY = startY + i * itemH;
        if (i === dropdownHoverIndex) {
          fill(240);
          rect(dbX + 2, itemY + 2, dbW - 4, itemH - 2, i === 0 ? 6 : 0, i === 0 ? 6 : 0, i === questionTypes.length - 1 ? 6 : 0, i === questionTypes.length - 1 ? 6 : 0);
        }
        fill(questionTypes[i] === questionType ? color(100, 60, 160) : 80);
        text(questionTypes[i], dbX + dbW/2, itemY + itemH/2);
      }
    }

    function drawEquationArea() {
      textAlign(CENTER, CENTER); textSize(52);
      textFont('Poppins'); fill(40);
      
      if (mode === 'challenge') {
        let eqStr = '';
        if (questionType === 'Distributive') {
          eqStr = distributiveA + '(x + ' + distributiveB + ') = ' + targetC;
        } else {
          let aStr = targetA === 1 ? 'x' : targetA + 'x';
          if (targetB === 0) {
            eqStr = aStr + ' = ' + targetC;
          } else if (targetB > 0) {
            eqStr = aStr + ' + ' + targetB + ' = ' + targetC;
          } else {
            eqStr = aStr + ' + (' + targetB + ') = ' + targetC;
          }
        }
        text(eqStr, 450, EQUATION_Y);
        
        // "Set up the problem:" text during build phase before setup is complete
        if (phase === 'build' && !(leftMatch && rightMatch)) {
          fill(140); textSize(16);
          text('Set up the problem:', 450, EQUATION_Y + 42);
        }
        
        if (leftMatch && rightMatch && phase === 'build') {
          drawCheckmark(720, EQUATION_Y, 1.2, color(34, 197, 94));
          drawCheckmark(770, EQUATION_Y, 1.2, color(34, 197, 94));
        }
        
        if (phase === 'solved') {
          drawCheckmark(700, EQUATION_Y, 1.2, color(34, 197, 94));
          drawCheckmark(750, EQUATION_Y, 1.2, color(34, 197, 94));
          drawCheckmark(800, EQUATION_Y, 1.2, color(34, 197, 94));
        }
      } else {
        let leftEq = buildSideEq(leftSide);
        let rightEq = buildSideEq(rightSide);
        if (leftEq || rightEq) {
          fill(60); text((leftEq || '?') + ' = ' + (rightEq || '?'), 450, EQUATION_Y);
          if (phase === 'solved') drawCheckmark(780, EQUATION_Y, 1.2, color(34, 197, 94));
        }
      }
    }
    
    function drawCheckmark(x, y, scale, col) {
      push(); translate(x, y);
      stroke(col); strokeWeight(5 * scale); noFill();
      beginShape();
      vertex(-14 * scale, 0);
      vertex(-4 * scale, 10 * scale);
      vertex(14 * scale, -10 * scale);
      endShape(); pop();
    }

    function drawSolveSteps() {
      if (solveSteps.length === 0) return;
      textAlign(CENTER, CENTER); textFont('Poppins'); textSize(28);
      let y = STEPS_START_Y;
      for (let step of solveSteps) {
        fill(50); text(step.left + ' = ' + step.right, 450, y);
        y += 38;
      }
    }

    function drawBalance() {
      let leftOffset = balanceTilt * balanceTiltMax;
      let rightOffset = -balanceTilt * balanceTiltMax;
      
      fill(30); noStroke();
      triangle(450, BALANCE_BEAM_Y + 8, 415, BALANCE_BEAM_Y + 55, 485, BALANCE_BEAM_Y + 55);
      fill(255); textSize(24); textAlign(CENTER, CENTER);
      
      if (phase === 'solve' && showWrongAnswer) {
        fill(255, 100, 100);
        text("≠", 450, BALANCE_BEAM_Y + 35);
      } else if (phase === 'solved') {
        fill(100, 255, 100);
        text("=", 450, BALANCE_BEAM_Y + 35);
      } else {
        fill(255);
        text("=", 450, BALANCE_BEAM_Y + 35);
      }
      
      stroke(30); strokeWeight(3);
      line(50, BALANCE_BEAM_Y + leftOffset, 415, BALANCE_BEAM_Y + leftOffset * 0.3);
      line(485, BALANCE_BEAM_Y + rightOffset * 0.3, 850, BALANCE_BEAM_Y + rightOffset);
      
      fill(170); noStroke(); textSize(13); textFont('Poppins');
      text('LEFT', 230, BALANCE_BEAM_Y + 18 + leftOffset * 0.6);
      text('RIGHT', 670, BALANCE_BEAM_Y + 18 + rightOffset * 0.6);
    }
    
    function drawZeroOutButton() {
      if (zeroOutAnimating) return;
      let hasZero = (leftSide.positiveCubes > 0 && leftSide.negativeCubes < 0) ||
                    (rightSide.positiveCubes > 0 && rightSide.negativeCubes < 0);
      if (hasZero) {
        let btnX = 450, btnY = BALANCE_BEAM_Y - 30;
        if (zeroOutHover) { fill(100, 60, 160); noStroke(); }
        else { fill(245); stroke(200); strokeWeight(1); }
        rect(btnX - 50, btnY - 14, 100, 28, 14);
        fill(zeroOutHover ? 255 : 100); noStroke();
        textSize(12); textFont('Poppins'); textAlign(CENTER, CENTER);
        text('ZERO OUT', btnX, btnY);
      }
    }
    
    function drawEquationDisplay() {
      let leftEq = buildSideEq(leftSide);
      let rightEq = buildSideEq(rightSide);
      if (leftEq === '' && rightEq === '') return;
      
      let leftOffset = balanceTilt * balanceTiltMax * 0.5;
      let rightOffset = -balanceTilt * balanceTiltMax * 0.5;
      
      textSize(32); textFont('Poppins'); textAlign(CENTER, CENTER);
      
      fill(60); text(leftEq || '0', 230, EQUATION_DISPLAY_Y + leftOffset);
      if (mode === 'challenge' && leftMatch && phase === 'build') {
        drawCheckmark(350, EQUATION_DISPLAY_Y + leftOffset, 0.8, color(34, 197, 94));
      }
      
      let showEquals = false;
      if (mode === 'build') {
        showEquals = true;
      } else if (phase === 'build') {
        showEquals = leftMatch && rightMatch;
      } else if (phase === 'solve') {
        showEquals = equationBalanced;
      } else if (phase === 'solved') {
        showEquals = true;
      }
      
      if (showEquals) {
        if (phase === 'solve' && showWrongAnswer) {
          fill(200, 80, 80); text('≠', 450, EQUATION_DISPLAY_Y);
        } else if (phase === 'solved') {
          fill(34, 197, 94); text('=', 450, EQUATION_DISPLAY_Y);
        } else {
          fill(140); text('=', 450, EQUATION_DISPLAY_Y);
        }
      }
      
      fill(60); text(rightEq || '0', 670, EQUATION_DISPLAY_Y + rightOffset);
      if (mode === 'challenge' && rightMatch && phase === 'build') {
        drawCheckmark(550, EQUATION_DISPLAY_Y + rightOffset, 0.8, color(34, 197, 94));
      }
    }
    
    function buildSideEq(side) {
      let parts = [];
      if (side.cups > 0) parts.push(side.cups === 1 ? 'x' : side.cups + 'x');
      if (side.positiveCubes > 0) {
        parts.push((parts.length > 0 ? '+ ' : '') + side.positiveCubes);
      }
      if (side.negativeCubes < 0) {
        if (parts.length > 0) parts.push('+ (' + side.negativeCubes + ')');
        else parts.push('' + side.negativeCubes);
      }
      return parts.join(' ');
    }

    function drawElementsOnBalance() {
      let leftOffset = balanceTilt * balanceTiltMax * 0.6;
      let rightOffset = -balanceTilt * balanceTiltMax * 0.6;
      
      for (let cup of cups) {
        if (cup !== selectedElement) {
          let yOff = cup.side === 'left' ? leftOffset : (cup.side === 'right' ? rightOffset : 0);
          drawCup(cup.x, cup.y + yOff, 75, 65);
          if ((phase === 'solve' || phase === 'solved') && xValue !== null && xValue !== 0) {
            drawCubesInCup(cup, yOff);
          }
        }
      }
      for (let cube of cubes) {
        if (cube !== selectedElement && !cube.zeroingOut) {
          let yOff = cube.side === 'left' ? leftOffset : (cube.side === 'right' ? rightOffset : 0);
          drawCubeUnit(cube.x, cube.y + yOff, cube.value);
        }
      }
    }
    
    function drawCubesInCup(cup, yOffset) {
      let size = 14, cols = 3;
      let absVal = Math.abs(xValue);
      let col = xValue > 0 ? 'green' : 'black';
      let startX = cup.x - (cols * size) / 2 + size/2;
      let startY = cup.y + yOffset + 22;
      
      for (let i = 0; i < absVal; i++) {
        let row = floor(i / cols);
        let c = i % cols;
        drawSingleCube(startX + c * (size + 2), startY - row * (size + 2), size, col);
      }
    }
    
    function getCubesInCupPositions(cup) {
      if (xValue === null || xValue === 0) return [];
      let positions = [];
      let size = 14, cols = 3;
      let absVal = Math.abs(xValue);
      let startX = cup.x - (cols * size) / 2 + size/2;
      let startY = cup.y + 22;
      for (let i = 0; i < absVal; i++) {
        let row = floor(i / cols), c = i % cols;
        positions.push({
          x: startX + c * (size + 2),
          y: startY - row * (size + 2),
          size: size
        });
      }
      return positions;
    }
    
    function drawCup(x, y, w, h) {
      fill(235, 245, 255, 200); stroke(170, 195, 220); strokeWeight(2);
      beginShape();
      vertex(x - w/2, y - h/2); vertex(x + w/2, y - h/2);
      vertex(x + w/2 * 0.82, y + h/2); vertex(x - w/2 * 0.82, y + h/2);
      endShape(CLOSE);
      stroke(190, 210, 230); strokeWeight(1);
      line(x - w/2, y - h/2, x + w/2, y - h/2);
    }
    
    function drawCubeUnit(x, y, value) {
      let size = 22, absVal = Math.abs(value);
      let col = value > 0 ? 'green' : 'black';
      if (absVal === 1) drawSingleCube(x, y, size, col);
      else if (absVal === 3) {
        drawSingleCube(x - size - 2, y, size, col);
        drawSingleCube(x, y, size, col);
        drawSingleCube(x + size + 2, y, size, col);
      } else if (absVal === 9) {
        let s = size - 2;
        for (let r = 0; r < 3; r++) for (let c = 0; c < 3; c++)
          drawSingleCube(x + (c - 1) * (s + 1), y + (r - 1) * (s + 1), s, col);
      }
    }
    
    function drawSingleCube(x, y, size, col) {
      let s = size, off = s * 0.22;
      if (col === 'green') {
        fill(0, 105, 0); noStroke();
        quad(x+s/2, y-s/2+off, x+s/2+off, y-s/2, x+s/2+off, y+s/2, x+s/2, y+s/2+off);
        fill(0, 175, 0);
        quad(x-s/2, y-s/2+off, x-s/2+off, y-s/2, x+s/2+off, y-s/2, x+s/2, y-s/2+off);
        fill(0, 140, 0); stroke(0, 95, 0); strokeWeight(1);
        rect(x - s/2, y - s/2 + off, s, s);
      } else {
        fill(50); noStroke();
        quad(x+s/2, y-s/2+off, x+s/2+off, y-s/2, x+s/2+off, y+s/2, x+s/2, y+s/2+off);
        fill(100);
        quad(x-s/2, y-s/2+off, x-s/2+off, y-s/2, x+s/2+off, y-s/2, x+s/2, y-s/2+off);
        fill(70); stroke(40); strokeWeight(1);
        rect(x - s/2, y - s/2 + off, s, s);
      }
    }
    
    function drawDraggedElement(elem) {
      if (elem.type === 'cup') drawCup(elem.x, elem.y, 80, 70);
      else drawCubeUnit(elem.x, elem.y, elem.value);
    }

    function drawButtons() {
      if (phase === 'build' && mode === 'challenge' && leftMatch && rightMatch) {
        let btnX = 450, btnY = BUTTON_Y;
        fill(solveButtonHover ? color(85, 50, 140) : color(100, 60, 160));
        noStroke(); rect(btnX - 70, btnY - 24, 140, 48, 12);
        fill(255); textSize(18); textFont('Poppins'); textAlign(CENTER, CENTER);
        text('Solve', btnX, btnY);
      }
      
      if (phase === 'build' && mode === 'build' && hasContent()) {
        let btnX = 450, btnY = BUTTON_Y;
        fill(solveButtonHover ? color(85, 50, 140) : color(100, 60, 160));
        noStroke(); rect(btnX - 70, btnY - 24, 140, 48, 12);
        fill(255); textSize(18); textFont('Poppins'); textAlign(CENTER, CENTER);
        text('Test a Value', btnX, btnY);
      }
      
      if (phase === 'solve' || phase === 'solved') drawXInput();
      
      if (phase === 'solved' && mode === 'challenge') {
        let btnX = 750, btnY = BUTTON_Y;
        fill(nextButtonHover ? color(85, 50, 140) : color(100, 60, 160));
        noStroke(); rect(btnX - 65, btnY - 22, 130, 44, 10);
        fill(255); textSize(15); textFont('Poppins'); textAlign(CENTER, CENTER);
        text('Next Question', btnX, btnY);
      }
    }
    
    function hasContent() {
      return leftSide.cups > 0 || leftSide.positiveCubes > 0 || leftSide.negativeCubes < 0 ||
             rightSide.cups > 0 || rightSide.positiveCubes > 0 || rightSide.negativeCubes < 0;
    }
    
    function drawXInput() {
      let inputX = 450, inputY = BUTTON_Y;
      fill(60); textSize(28); textFont('Poppins');
      textAlign(RIGHT, CENTER); text('x =', inputX - 50, inputY);
      
      fill(255);
      if (phase === 'solved') { stroke(34, 197, 94); strokeWeight(3); }
      else if (xInputFocused) { stroke(100, 60, 160); strokeWeight(2); }
      else { stroke(190); strokeWeight(1); }
      rect(inputX - 35, inputY - 24, 90, 48, 8);
      
      noStroke(); textAlign(CENTER, CENTER);
      if (xValue !== null) { fill(40); text(xValue, inputX + 10, inputY); }
      else if (xInputFocused && phase === 'solve') {
        if (floor(cursorBlink / 30) % 2 === 0) {
          stroke(100, 60, 160); strokeWeight(2);
          line(inputX + 10, inputY - 12, inputX + 10, inputY + 12);
        }
      }
      
      if (phase === 'solve') {
        let qX = inputX + 95, qY = inputY; // moved 20px right
        fill(checkHover ? color(100, 60, 160) : 220);
        noStroke(); ellipse(qX, qY, 36, 36);
        fill(checkHover ? 255 : 80);
        textSize(22); textAlign(CENTER, CENTER);
        text('?', qX, qY);
      }
    }

    function drawSourceArea() {
      stroke(230); strokeWeight(1);
      line(60, SOURCE_Y - 55, 840, SOURCE_Y - 55);
      
      // Cup at far left
      drawCup(70, SOURCE_Y, 60, 52);
      fill(150); noStroke(); textSize(11); textFont('Poppins'); textAlign(CENTER);
      text('x', 70, SOURCE_Y + 42);
      
      // Vertical separator
      stroke(210); strokeWeight(1);
      line(130, SOURCE_Y - 35, 130, SOURCE_Y + 35);
      
      // Order: -9, -3, -1, +1, +3, +9
      drawCubeUnit(200, SOURCE_Y, -9); fill(60); noStroke(); text('-9', 200, SOURCE_Y + 42);
      drawCubeUnit(310, SOURCE_Y, -3); fill(60); text('-3', 310, SOURCE_Y + 42);
      drawSingleCube(400, SOURCE_Y, 22, 'black'); fill(60); text('-1', 400, SOURCE_Y + 42);
      
      drawSingleCube(500, SOURCE_Y, 22, 'green'); fill(34, 139, 34); text('+1', 500, SOURCE_Y + 42);
      drawCubeUnit(590, SOURCE_Y, 3); fill(34, 139, 34); text('+3', 590, SOURCE_Y + 42);
      drawCubeUnit(700, SOURCE_Y, 9); fill(34, 139, 34); text('+9', 700, SOURCE_Y + 42);
      
      // Clear button at lower right
      let clearX = 820, clearY = SOURCE_Y;
      fill(clearButtonHover ? 240 : 250);
      stroke(220); strokeWeight(1);
      rect(clearX - 35, clearY - 16, 70, 32, 16);
      fill(clearButtonHover ? 100 : 150); noStroke();
      textSize(13); textAlign(CENTER, CENTER);
      text('Clear', clearX, clearY);
    }

    function drawZeroOutAnimation() {
      if (!zeroOutAnimating) return;
      
      let p = zeroOutProgress;
      
      for (let pair of zeroOutPairs) {
        if (p < 0.5) {
          let t = p / 0.5;
          let x1 = lerp(pair.gx, pair.mx - 14, t);
          let x2 = lerp(pair.bx, pair.mx + 14, t);
          let y1 = lerp(pair.gy, pair.my, t);
          let y2 = lerp(pair.by, pair.my, t);
          drawSingleCube(x1, y1, 22, 'green');
          drawSingleCube(x2, y2, 22, 'black');
        } else if (p < 0.85) {
          let t = (p - 0.5) / 0.35;
          let dropY = lerp(pair.my, SOURCE_Y, t);
          drawSingleCube(pair.mx - 14, dropY, 22, 'green');
          drawSingleCube(pair.mx + 14, dropY, 22, 'black');
        }
      }
    }
    
    function startZeroOut() {
      zeroOutAnimating = true;
      zeroOutProgress = 0;
      zeroOutPairs = [];
      
      for (let side of ['left', 'right']) {
        let sideCubes = cubes.filter(c => c.side === side);
        let posTotal = sideCubes.filter(c => c.value > 0).reduce((s, c) => s + c.value, 0);
        let negTotal = Math.abs(sideCubes.filter(c => c.value < 0).reduce((s, c) => s + c.value, 0));
        
        if (posTotal === 0 || negTotal === 0) continue;
        
        let toCancel = min(posTotal, negTotal);
        
        let posCubes = sideCubes.filter(c => c.value > 0).slice();
        let negCubes = sideCubes.filter(c => c.value < 0).slice();
        
        posCubes.sort((a, b) => a.value - b.value);
        negCubes.sort((a, b) => Math.abs(a.value) - Math.abs(b.value));
        
        let posRemaining = toCancel;
        let negRemaining = toCancel;
        
        let posToRemove = [];
        let negToRemove = [];
        
        for (let cube of posCubes) {
          if (posRemaining <= 0) break;
          
          if (cube.value <= posRemaining) {
            cube.zeroingOut = true;
            for (let i = 0; i < cube.value; i++) {
              posToRemove.push({ x: cube.x + random(-10, 10), y: cube.y + random(-10, 10) });
            }
            posRemaining -= cube.value;
          } else {
            let removeCount = posRemaining;
            let keepCount = cube.value - removeCount;
            let origX = cube.x, origY = cube.y;
            let origValue = cube.value;
            let isPositive = cube.value > 0;
            
            let idx = cubes.indexOf(cube);
            if (idx > -1) cubes.splice(idx, 1);
            
            let keepPositions = getBlockPositions(origX, origY, origValue);
            for (let i = 0; i < keepCount; i++) {
              let pos = keepPositions[i];
              cubes.push({ type: 'cube', x: pos.x, y: pos.y, side: side, value: isPositive ? 1 : -1 });
            }
            
            for (let i = keepCount; i < origValue; i++) {
              let pos = keepPositions[i];
              posToRemove.push({ x: pos.x, y: pos.y });
            }
            
            posRemaining = 0;
          }
        }
        
        for (let cube of negCubes) {
          if (negRemaining <= 0) break;
          
          let absVal = Math.abs(cube.value);
          
          if (absVal <= negRemaining) {
            cube.zeroingOut = true;
            for (let i = 0; i < absVal; i++) {
              negToRemove.push({ x: cube.x + random(-10, 10), y: cube.y + random(-10, 10) });
            }
            negRemaining -= absVal;
          } else {
            let removeCount = negRemaining;
            let keepCount = absVal - removeCount;
            let origX = cube.x, origY = cube.y;
            let origAbsValue = absVal;
            
            let idx = cubes.indexOf(cube);
            if (idx > -1) cubes.splice(idx, 1);
            
            let keepPositions = getBlockPositions(origX, origY, origAbsValue);
            for (let i = 0; i < keepCount; i++) {
              let pos = keepPositions[i];
              cubes.push({ type: 'cube', x: pos.x, y: pos.y, side: side, value: -1 });
            }
            
            for (let i = keepCount; i < origAbsValue; i++) {
              let pos = keepPositions[i];
              negToRemove.push({ x: pos.x, y: pos.y });
            }
            
            negRemaining = 0;
          }
        }
        
        let pairCount = min(posToRemove.length, negToRemove.length);
        for (let i = 0; i < pairCount; i++) {
          let p = posToRemove[i];
          let n = negToRemove[i];
          zeroOutPairs.push({
            gx: p.x, gy: p.y,
            bx: n.x, by: n.y,
            mx: (p.x + n.x) / 2,
            my: (p.y + n.y) / 2
          });
        }
      }
    }
    
    function getBlockPositions(x, y, absValue) {
      let positions = [];
      let size = 22;
      
      if (absValue === 1) {
        positions.push({ x: x, y: y });
      } else if (absValue === 3) {
        positions.push({ x: x - size - 2, y: y });
        positions.push({ x: x, y: y });
        positions.push({ x: x + size + 2, y: y });
      } else if (absValue === 9) {
        let s = size - 2;
        for (let r = 0; r < 3; r++) {
          for (let c = 0; c < 3; c++) {
            positions.push({ x: x + (c - 1) * (s + 1), y: y + (r - 1) * (s + 1) });
          }
        }
      }
      return positions;
    }
    
    function splitBlockIntoIndividualCubes(cube, side) {
      let absVal = Math.abs(cube.value);
      if (absVal === 1) return; // Already individual
      
      let positions = getBlockPositions(cube.x, cube.y, absVal);
      let unitValue = cube.value > 0 ? 1 : -1;
      
      // Remove original block
      let idx = cubes.indexOf(cube);
      if (idx > -1) cubes.splice(idx, 1);
      
      // Add individual cubes
      for (let pos of positions) {
        cubes.push({ 
          type: 'cube', 
          x: pos.x, 
          y: pos.y, 
          side: side, 
          value: unitValue,
          solvePaired: cube.solvePaired,
          pairId: cube.pairId
        });
      }
    }
    
    function finishZeroOut() {
      cubes = cubes.filter(c => !c.zeroingOut);
      zeroOutAnimating = false;
      zeroOutPairs = [];
      recalcSides();
      
      equationBalanced = true;
      
      if (phase === 'solve') updateSolveStep();
    }

    function drawFadingElements() {
      for (let elem of fadingElements) {
        if (elem.type === 'cup') {
          fill(235, 245, 255, elem.alpha * 0.8);
          stroke(170, 195, 220, elem.alpha); strokeWeight(2);
          beginShape();
          vertex(elem.x - 37, elem.y - 32); vertex(elem.x + 37, elem.y - 32);
          vertex(elem.x + 30, elem.y + 32); vertex(elem.x - 30, elem.y + 32);
          endShape(CLOSE);
        }
      }
    }
    
    function updateAnimations() {
      cursorBlink++;
      
      if (showWrongAnswer) {
        if (xValue !== null) {
          let leftVal = leftSide.cups * xValue + leftSide.positiveCubes + leftSide.negativeCubes;
          let rightVal = rightSide.cups * xValue + rightSide.positiveCubes + rightSide.negativeCubes;
          if (leftVal > rightVal) {
            balanceTiltTarget = 1;
          } else if (rightVal > leftVal) {
            balanceTiltTarget = -1;
          } else {
            balanceTiltTarget = 0;
          }
        }
      } else {
        balanceTiltTarget = 0;
      }
      
      balanceTilt += (balanceTiltTarget - balanceTilt) * 0.15;
      if (abs(balanceTilt - balanceTiltTarget) < 0.01) balanceTilt = balanceTiltTarget;
      
      if (showWrongAnswer) {
        wrongAnswerTimer++;
        if (wrongAnswerTimer > 90) {
          showWrongAnswer = false;
          wrongAnswerTimer = 0;
        }
      }
      for (let i = fadingElements.length - 1; i >= 0; i--) {
        fadingElements[i].alpha -= 15;
        if (fadingElements[i].alpha <= 0) fadingElements.splice(i, 1);
      }
      if (zeroOutAnimating) {
        zeroOutProgress += 0.02;
        if (zeroOutProgress >= 1) finishZeroOut();
      }
    }

    function getCubeRadius(value) {
      let absVal = Math.abs(value);
      if (absVal === 9) return 45;
      if (absVal === 3) return 42;
      return 22;
    }

    function canPlaceCupAt(x, y) {
      const CUP_RADIUS = 45;
      for (let cube of cubes) {
        let cubeRadius = getCubeRadius(cube.value);
        if (dist(x, y, cube.x, cube.y) < CUP_RADIUS + cubeRadius) return false;
      }
      return true;
    }

    function mousePressed() {
      let mx = mouseX, my = mouseY;
      
      // Close dropdown if clicking elsewhere
      if (dropdownOpen) {
        let dbX = 25, dbW = 130, itemH = 28;
        let startY = DROPDOWN_Y + 28;
        let dropdownH = questionTypes.length * itemH;
        
        if (mx > dbX && mx < dbX + dbW && my > startY && my < startY + dropdownH) {
          let clickedIndex = floor((my - startY) / itemH);
          if (clickedIndex >= 0 && clickedIndex < questionTypes.length) {
            questionType = questionTypes[clickedIndex];
            generateNewProblem();
          }
        }
        dropdownOpen = false;
        return;
      }
      
      if (my > TABS_Y && my < TABS_Y + 32) {
        if (mx > 25 && mx < 125 && mode !== 'challenge') { mode = 'challenge'; generateNewProblem(); return; }
        if (mx > 165 && mx < 305 && mode !== 'build') { mode = 'build'; generateNewProblem(); return; }
        if (mx > 630 && mx < 750) { generateNewProblem(); return; }
      }
      
      // Dropdown button
      if (mode === 'challenge' && mx > 25 && mx < 155 && my > DROPDOWN_Y && my < DROPDOWN_Y + 24) {
        dropdownOpen = !dropdownOpen;
        return;
      }
      
      // Clear button
      if (mx > 785 && mx < 855 && my > SOURCE_Y - 16 && my < SOURCE_Y + 16) {
        clearBalance(); return;
      }
      
      if (phase === 'solved' && mode === 'challenge' && mx > 685 && mx < 815 && my > BUTTON_Y - 22 && my < BUTTON_Y + 22) {
        generateNewProblem(); return;
      }
      
      if (phase === 'solve' && xValue !== null) {
        let qX = 450 + 95, qY = BUTTON_Y;
        if (dist(mx, my, qX, qY) < 20) { checkAnswer(); return; }
      }
      
      if ((phase === 'solve' || phase === 'solved') && mx > 415 && mx < 505 && my > BUTTON_Y - 24 && my < BUTTON_Y + 24) {
        xInputFocused = true; return;
      } else xInputFocused = false;
      
      let hasZero = (leftSide.positiveCubes > 0 && leftSide.negativeCubes < 0) ||
                    (rightSide.positiveCubes > 0 && rightSide.negativeCubes < 0);
      if (hasZero && !zeroOutAnimating && mx > 400 && mx < 500 && my > BALANCE_BEAM_Y - 44 && my < BALANCE_BEAM_Y - 16) {
        startZeroOut(); return;
      }
      
      if (phase === 'build') {
        let canSolve = (mode === 'challenge' && leftMatch && rightMatch) || (mode === 'build' && hasContent());
        if (canSolve && mx > 380 && mx < 520 && my > BUTTON_Y - 24 && my < BUTTON_Y + 24) {
          startSolveMode(); return;
        }
      }
      
      if ((phase === 'solve' || phase === 'solved') && xValue !== null && xValue !== 0) {
        for (let cup of cups) {
          let cubePositions = getCubesInCupPositions(cup);
          for (let pos of cubePositions) {
            if (dist(mx, my, pos.x, pos.y) < pos.size / 2 + 4) {
              let newCubeValue = xValue > 0 ? 1 : -1;
              selectedElement = { 
                type: 'cube', 
                x: mx, 
                y: my, 
                side: null, 
                value: newCubeValue, 
                isNew: true,
                fromCup: true 
              };
              cubes.push(selectedElement);
              dragOffsetX = 0;
              dragOffsetY = 0;
              
              if (xValue > 0) xValue--;
              else xValue++;
              if (xValue === 0) xValue = null;
              
              equationBalanced = false;
              
              return;
            }
          }
        }
      }
      
      for (let cup of cups) {
        if (dist(mx, my, cup.x, cup.y) < 42) {
          selectedElement = cup;
          dragOffsetX = cup.x - mx; dragOffsetY = cup.y - my;
          return;
        }
      }
      
      for (let cube of cubes) {
        let hitR = getCubeRadius(cube.value);
        if (dist(mx, my, cube.x, cube.y) < hitR) {
          selectedElement = cube;
          dragOffsetX = cube.x - mx; dragOffsetY = cube.y - my;
          return;
        }
      }
      
      // Source elements - new order: cup | -9, -3, -1, +1, +3, +9
      if (dist(mx, my, 70, SOURCE_Y) < 38) {
        selectedElement = { type: 'cup', x: mx, y: my, side: null, isNew: true };
        cups.push(selectedElement); return;
      }
      if (dist(mx, my, 200, SOURCE_Y) < 50) {
        selectedElement = { type: 'cube', x: mx, y: my, side: null, value: -9, isNew: true };
        cubes.push(selectedElement); return;
      }
      if (dist(mx, my, 310, SOURCE_Y) < 42) {
        selectedElement = { type: 'cube', x: mx, y: my, side: null, value: -3, isNew: true };
        cubes.push(selectedElement); return;
      }
      if (dist(mx, my, 400, SOURCE_Y) < 22) {
        selectedElement = { type: 'cube', x: mx, y: my, side: null, value: -1, isNew: true };
        cubes.push(selectedElement); return;
      }
      if (dist(mx, my, 500, SOURCE_Y) < 22) {
        selectedElement = { type: 'cube', x: mx, y: my, side: null, value: 1, isNew: true };
        cubes.push(selectedElement); return;
      }
      if (dist(mx, my, 590, SOURCE_Y) < 42) {
        selectedElement = { type: 'cube', x: mx, y: my, side: null, value: 3, isNew: true };
        cubes.push(selectedElement); return;
      }
      if (dist(mx, my, 700, SOURCE_Y) < 50) {
        selectedElement = { type: 'cube', x: mx, y: my, side: null, value: 9, isNew: true };
        cubes.push(selectedElement); return;
      }
    }
    
    function mouseDragged() {
      if (selectedElement) {
        selectedElement.x = mouseX + dragOffsetX;
        selectedElement.y = mouseY + dragOffsetY;
      }
    }
    
    function mouseReleased() {
      if (!selectedElement) return;
      let elem = selectedElement;
      selectedElement = null;
      
      let onBalance = elem.y < BALANCE_BEAM_Y - 20 && elem.y > 150;
      let onLeft = elem.x > 50 && elem.x < 415;
      let onRight = elem.x > 485 && elem.x < 850;
      
      if (elem.type === 'cube') {
        let cup = findCupAt(elem.x, elem.y);
        if (cup) {
          if (xValue === null) xValue = elem.value;
          else xValue += elem.value;
          let idx = cubes.indexOf(elem);
          if (idx > -1) cubes.splice(idx, 1);
          
          equationBalanced = false;
          
          return;
        }
      }
      
      if (onBalance && (onLeft || onRight)) {
        let newSide = onLeft ? 'left' : 'right';
        
        if (elem.type === 'cup') {
          if (!canPlaceCupAt(elem.x, elem.y)) {
            let idx = cups.indexOf(elem);
            if (idx > -1) { fadingElements.push({ ...elem, alpha: 255 }); cups.splice(idx, 1); }
            recalcSides(); checkSetup();
            return;
          }
        }
        
        if (phase === 'solve' && elem.isNew) {
          elem.side = newSide; elem.isNew = false;
          elem.solvePaired = true;
          let mirrorSide = newSide === 'left' ? 'right' : 'left';
          let mirrorX = newSide === 'left' ? elem.x + 440 : elem.x - 440;
          let mirror;
          if (elem.type === 'cup') {
            mirror = { type: 'cup', x: mirrorX, y: elem.y, side: mirrorSide, solvePaired: true, pairId: elem };
            cups.push(mirror);
          } else {
            mirror = { type: 'cube', x: mirrorX, y: elem.y, side: mirrorSide, value: elem.value, solvePaired: true, pairId: elem };
            cubes.push(mirror);
            // Split both blocks into individual cubes
            if (Math.abs(elem.value) > 1) {
              splitBlockIntoIndividualCubes(elem, newSide);
              splitBlockIntoIndividualCubes(mirror, mirrorSide);
            }
          }
          elem.pairId = mirror;
          recalcSides(); updateSolveStep();
          
          equationBalanced = true;
          
          return;
        }
        
        elem.side = newSide; elem.isNew = false;
        
        // Split blocks into individual cubes when placed on balance
        if (elem.type === 'cube' && Math.abs(elem.value) > 1) {
          splitBlockIntoIndividualCubes(elem, newSide);
        }
        
        recalcSides(); checkSetup();
      } else {
        // Element being removed from balance
        let elemSide = elem.side;
        let otherSide = elemSide === 'left' ? 'right' : 'left';
        
        // In challenge mode solve phase, mirror the removal to the other side
        if (phase === 'solve' && mode === 'challenge' && elemSide) {
          if (elem.solvePaired && elem.pairId) {
            // Already paired - remove the pair
            if (elem.type === 'cup') {
              let idx = cups.indexOf(elem.pairId);
              if (idx > -1) cups.splice(idx, 1);
            } else {
              let idx = cubes.indexOf(elem.pairId);
              if (idx > -1) cubes.splice(idx, 1);
            }
          } else {
            // Not paired - find and remove matching element from other side
            if (elem.type === 'cup') {
              let otherCup = cups.find(c => c.side === otherSide && c !== elem);
              if (otherCup) {
                let idx = cups.indexOf(otherCup);
                if (idx > -1) cups.splice(idx, 1);
              }
            } else {
              // Find a cube with same value on other side
              let otherCube = cubes.find(c => c.side === otherSide && c.value === elem.value && c !== elem);
              if (otherCube) {
                let idx = cubes.indexOf(otherCube);
                if (idx > -1) cubes.splice(idx, 1);
              }
            }
          }
        } else if (phase === 'solve' && elem.solvePaired && elem.pairId) {
          // Build mode or non-challenge: just remove paired element
          if (elem.type === 'cup') {
            let idx = cups.indexOf(elem.pairId);
            if (idx > -1) cups.splice(idx, 1);
          } else {
            let idx = cubes.indexOf(elem.pairId);
            if (idx > -1) cubes.splice(idx, 1);
          }
        }
        
        // Remove the dragged element itself
        if (elem.type === 'cup') {
          let idx = cups.indexOf(elem);
          if (idx > -1) { fadingElements.push({ ...elem, alpha: 255 }); cups.splice(idx, 1); }
        } else {
          let idx = cubes.indexOf(elem);
          if (idx > -1) cubes.splice(idx, 1);
        }
        recalcSides(); checkSetup();
        
        if (phase === 'solve') {
          updateSolveStep();
          equationBalanced = true; // Mirrored removal keeps balance
        }
      }
    }
    
    function findCupAt(x, y) {
      for (let cup of cups) if (dist(x, y, cup.x, cup.y) < 50) return cup;
      return null;
    }
    
    function mouseMoved() {
      let canSolve = (mode === 'challenge' && leftMatch && rightMatch) || (mode === 'build' && hasContent());
      solveButtonHover = (phase === 'build' && canSolve && mouseX > 380 && mouseX < 520 && mouseY > BUTTON_Y - 24 && mouseY < BUTTON_Y + 24);
      challengeTabHover = (mouseY > TABS_Y && mouseY < TABS_Y + 32 && mouseX > 25 && mouseX < 125);
      buildTabHover = (mouseY > TABS_Y && mouseY < TABS_Y + 32 && mouseX > 165 && mouseX < 305);
      newQuestionHover = (mouseY > TABS_Y && mouseY < TABS_Y + 32 && mouseX > 630 && mouseX < 750);
      nextButtonHover = (phase === 'solved' && mode === 'challenge' && mouseX > 685 && mouseX < 815 && mouseY > BUTTON_Y - 22 && mouseY < BUTTON_Y + 22);
      let hasZero = (leftSide.positiveCubes > 0 && leftSide.negativeCubes < 0) || (rightSide.positiveCubes > 0 && rightSide.negativeCubes < 0);
      zeroOutHover = (hasZero && mouseX > 400 && mouseX < 500 && mouseY > BALANCE_BEAM_Y - 44 && mouseY < BALANCE_BEAM_Y - 16);
      
      // Clear button hover
      clearButtonHover = (mouseX > 785 && mouseX < 855 && mouseY > SOURCE_Y - 16 && mouseY < SOURCE_Y + 16);
      
      // Dropdown button hover
      dropdownButtonHover = (mode === 'challenge' && mouseX > 25 && mouseX < 155 && mouseY > DROPDOWN_Y && mouseY < DROPDOWN_Y + 24);
      
      // Dropdown hover
      if (dropdownOpen && mode === 'challenge') {
        let dbX = 25, dbW = 130, itemH = 28;
        let startY = DROPDOWN_Y + 28;
        if (mouseX > dbX && mouseX < dbX + dbW && mouseY > startY && mouseY < startY + questionTypes.length * itemH) {
          dropdownHoverIndex = floor((mouseY - startY) / itemH);
        } else {
          dropdownHoverIndex = -1;
        }
      } else {
        dropdownHoverIndex = -1;
      }
      
      if (phase === 'solve') {
        let qX = 450 + 95, qY = BUTTON_Y;
        checkHover = dist(mouseX, mouseY, qX, qY) < 20;
      } else checkHover = false;
    }
    
    function keyPressed() {
      if (phase === 'solve' && xInputFocused) {
        if (key === '-') {
          if (xValue === null) xValue = 0;
          xValue = -xValue;
        } else if (key >= '0' && key <= '9') {
          let d = int(key);
          if (xValue === null) xValue = d;
          else if (xValue >= 0) { xValue = xValue * 10 + d; if (xValue > 99) xValue = d; }
          else { xValue = xValue * 10 - d; if (xValue < -99) xValue = -d; }
          
          equationBalanced = false;
        } else if (keyCode === BACKSPACE) {
          if (xValue !== null) {
            if (Math.abs(xValue) < 10) xValue = null;
            else xValue = floor(xValue / 10);
          }
          equationBalanced = false;
        } else if (keyCode === ENTER || keyCode === RETURN) {
          if (xValue !== null) checkAnswer();
        }
      }
    }
    
    function checkAnswer() {
      if (xValue === null) return;
      
      if (mode === 'challenge') {
        if (xValue === targetSolution) {
          solveSteps.push({ left: 'x', right: '' + targetSolution });
          phase = 'solved';
          equationBalanced = true;
        } else {
          showWrongAnswer = true;
          wrongAnswerTimer = 0;
        }
      } else {
        let l = leftSide.cups * xValue + leftSide.positiveCubes + leftSide.negativeCubes;
        let r = rightSide.cups * xValue + rightSide.positiveCubes + rightSide.negativeCubes;
        if (l === r) {
          solveSteps.push({ left: 'x', right: '' + xValue });
          phase = 'solved';
          equationBalanced = true;
        } else {
          showWrongAnswer = true;
          wrongAnswerTimer = 0;
        }
      }
    }

    function recalcSides() {
      leftSide.cups = cups.filter(c => c.side === 'left').length;
      leftSide.positiveCubes = cubes.filter(c => c.side === 'left' && c.value > 0).reduce((s, c) => s + c.value, 0);
      leftSide.negativeCubes = cubes.filter(c => c.side === 'left' && c.value < 0).reduce((s, c) => s + c.value, 0);
      rightSide.cups = cups.filter(c => c.side === 'right').length;
      rightSide.positiveCubes = cubes.filter(c => c.side === 'right' && c.value > 0).reduce((s, c) => s + c.value, 0);
      rightSide.negativeCubes = cubes.filter(c => c.side === 'right' && c.value < 0).reduce((s, c) => s + c.value, 0);
    }
    
    function checkSetup() {
      if (mode === 'challenge') {
        let lTotal = leftSide.positiveCubes + leftSide.negativeCubes;
        let rTotal = rightSide.positiveCubes + rightSide.negativeCubes;
        leftMatch = (leftSide.cups === targetA && lTotal === targetB);
        rightMatch = (rightSide.cups === 0 && rTotal === targetC);
      }
    }
    
    function startSolveMode() {
      phase = 'solve'; solveSteps = []; xValue = null; xInputFocused = true;
      showWrongAnswer = false;
      equationBalanced = true;
    }
    
    function updateSolveStep() {
      let l = buildSideEq(leftSide), r = buildSideEq(rightSide);
      solveSteps.push({ left: l, right: r });
      if (solveSteps.length > 4) solveSteps.shift();
    }

    function touchStarted() { mousePressed(); return false; }
    function touchMoved() { mouseDragged(); return false; }
    function touchEnded() { mouseReleased(); return false; }
  </script>
</body>
</html>
